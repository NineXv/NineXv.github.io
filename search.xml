<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>瞧瞧你发现了什么</title>
      <link href="/2029/04/15/%E7%BD%AE%E9%A1%B6/"/>
      <url>/2029/04/15/%E7%BD%AE%E9%A1%B6/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="欢迎访问我的博客"><a href="#欢迎访问我的博客" class="headerlink" title="欢迎访问我的博客"></a>欢迎访问我的博客</h1><p>本博客都是我自己学习过程中积累下的一些笔记<br>算不上高深，只是用来备忘和积累<br>如果有错误，还请高手能够多多指点！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2019/04/20/Spring/Maven/"/>
      <url>/2019/04/20/Spring/Maven/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven入门"><a href="#Maven入门" class="headerlink" title="Maven入门"></a>Maven入门</h1><a id="more"></a><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>   1.解压Maven的压缩文件<br>   2.配置环境变量 MAVEN_HOME (将第一步解压的文件所在的路径设置进去)<br>   3.在Path变量中配置 %MAVEN_HOME%\bin<br>   以上就完成了安装，具体成功与否可以在DOS命令行中使用 mvn -n 测试   </p><h2 id="MAVEN的仓库"><a href="#MAVEN的仓库" class="headerlink" title="MAVEN的仓库"></a>MAVEN的仓库</h2><p>   1.本地仓库:在setting.xml中配置，默认在${user.home}/.m2/repository中<br>   2.远程仓库(私服):公司内部局域网的仓库<br>   3.中央仓库：网络上的仓库<br>   本地-&gt;私服-&gt;中央</p><p>   注：修改本地仓库默认地方，可以在setting.xml中复制<localrepository>/path/to/local/repo</localrepository>并修改中间的路径即可</p><h2 id="MAVEN项目的目录结构"><a href="#MAVEN项目的目录结构" class="headerlink" title="MAVEN项目的目录结构"></a>MAVEN项目的目录结构</h2><p>   src/main/java        核心代码部分<br>   src/main/resources   配置文件部分<br>   src/test/java        测试代码部分<br>   src/test/resources   测试配置文件<br>   src/main/webapp      前端页面资源</p><h2 id="MAVEN常用命令"><a href="#MAVEN常用命令" class="headerlink" title="MAVEN常用命令"></a>MAVEN常用命令</h2><p>   <strong>MAVEN的默认生命周期</strong><br>   mvn conplie  将核心代码部分编译到target文件下的classes中<br>   mvn test     将所有(核心+测试)代码编译到target文件<br>   mvn package  将项目编译并打成war包到target文件<br>   mvn install  将项目编译并打成war包到target文件，然后安装到本地仓库<br>   mvn deploy   发布</p><p>   mvn clean    清除target文件</p><p>   tomcat:run   启动tomcat</p><h2 id="pom-xml的信息"><a href="#pom-xml的信息" class="headerlink" title="pom.xml的信息"></a>pom.xml的信息</h2><p>   <strong>项目自身信息</strong></p><p>   <strong>项目运行所依赖的jar包信息</strong>(Dependency)<br>    <dependency><br>        <groupld> 公司组织的名称 </groupld><br>        <artifactld> 项目名 </artifactld><br>        <version> 版本号 </version><br>    </dependency></p><p>   <strong>项目运行环境信息</strong>，比如:jdk,tomcat信息</p><hr><h1 id="IDEA集成Maven"><a href="#IDEA集成Maven" class="headerlink" title="IDEA集成Maven"></a>IDEA集成Maven</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>   setting –&gt; 搜索Maven –&gt; 修改默认的配置为自己本机的maven路径即可</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><pre><code>1.java项目 选择Maven，可以选择骨架 quickjava，也可以直接不选骨架2.javaweb项目 选择Maven，可以选择骨架 webapp</code></pre><h1 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h1><h2 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h2><pre><code>首先，我想用maven启动tomcat运行我的一个项目，却出现了ClassCastException**原因**：在pom.xml中导包和在tomcat自带的lib文件中的包产生了冲突**解决方案**：使用 &lt;scope&gt;provided&lt;scope&gt;标签，使其在打包的时候不打包进去。</code></pre><h2 id="问题二：tomcat的版本问题"><a href="#问题二：tomcat的版本问题" class="headerlink" title="问题二：tomcat的版本问题"></a>问题二：tomcat的版本问题</h2><pre><code>org.apache.jasper.JasperException: Unable to compile class for JSP 这个问题的原因是因为我是用的事jdk1.8，而maven默认使用的是tomcat6，6是不支持1.8版本的**解决方法**：在&lt;bulid&gt;&lt;/bulid&gt;里边添加&lt;plugin&gt;  &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;  &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;  &lt;version&gt;2.2&lt;/version&gt;&lt;/plugin&gt;此时使用tomcat7:run命令就可以了</code></pre><h2 id="scope详解"><a href="#scope详解" class="headerlink" title="scope详解"></a>scope详解</h2><h3 id="scope的分类"><a href="#scope的分类" class="headerlink" title="scope的分类"></a>scope的分类</h3><p> 1.compile：默认值 他表示被依赖项目需要参与当前项目的编译，还有后续的测试，运行周期也参与其中，是一个比较强的依赖。打包的时候通常需要包含进去</p><p> 2.test：依赖项目仅仅参与测试相关的工作，包括测试代码的编译和执行，不会被打包，例如：junit</p><p> 3.runtime：表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与compile相比，跳过了编译而已。例如JDBC驱动，适用运行和测试阶段</p><p> 4.provided：打包的时候可以不用包进去，别的设施会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是打包阶段做了exclude操作</p><p> 5.system：从参与度来说，和provided相同，不过被依赖项不会从maven仓库下载，而是从本地文件系统拿。需要添加systemPath的属性来定义路径</p><h3 id="scope的依赖传递"><a href="#scope的依赖传递" class="headerlink" title="scope的依赖传递"></a>scope的依赖传递</h3><pre><code>A依赖B，B依赖C。当前项目为A，只当B在A项目中的scope，那么c在A中的scope是如何得知呢？当C是test或者provided时，C直接被丢弃，A不依赖C；（排除传递依赖）否则A依赖C，C的scope继承与B的scope</code></pre>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring_aop</title>
      <link href="/2019/04/19/Spring/Spring-aop/"/>
      <url>/2019/04/19/Spring/Spring-aop/</url>
      
        <content type="html"><![CDATA[<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><a id="more"></a><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><p><strong>切面</strong>：横切关注点(跨越应用程序多个模块的功能)被模块化的特殊对象<br><strong>通知</strong>：切面必须要完成的工作<br><strong>目标</strong>：被通知的对象<br><strong>代理</strong>：向目标对象应用通知之后创建的对象<br><strong>连接点</strong>：程序执行的某个特定位置<br><strong>切点</strong>：AOP通过切点定位到特定的连接点</p><h2 id="注：切点和连接点不是一一对应关系，而是一个切点匹配多个连接点"><a href="#注：切点和连接点不是一一对应关系，而是一个切点匹配多个连接点" class="headerlink" title="   注：切点和连接点不是一一对应关系，而是一个切点匹配多个连接点"></a>   <em>注</em>：切点和连接点不是一一对应关系，而是一个切点匹配多个连接点</h2><h1 id="SPring-AOP基于注解的方式开发"><a href="#SPring-AOP基于注解的方式开发" class="headerlink" title="SPring AOP基于注解的方式开发"></a>SPring AOP基于注解的方式开发</h1><h2 id="步骤：基于注解的方式"><a href="#步骤：基于注解的方式" class="headerlink" title="步骤：基于注解的方式"></a>步骤：基于注解的方式</h2><h3 id="1-额外导包"><a href="#1-额外导包" class="headerlink" title="1.额外导包"></a>1.额外导包</h3><pre><code>Spring-aop包，Spring-aspects包，springsource.org.aoplliance包，springsource.org.aspectj.weaver包       </code></pre><hr><h3 id="2-配置XML"><a href="#2-配置XML" class="headerlink" title="2.配置XML"></a>2.配置XML</h3><pre><code>为了使Aspjectj注解起作用,自动为匹配的类生成代理对象需要在xml文件中添加aop的命名空间xmlns:aop=&quot;http://www.springframework.org/chema/aop&quot;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</code></pre><hr><h3 id="3-编写切面类"><a href="#3-编写切面类" class="headerlink" title="3.编写切面类"></a>3.编写切面类</h3><pre><code>把横切关注点的代码抽象到切面的类中   i.切面首先是一个IOC中的bean，即加入@Component 注解   ii.为类添加注解@Aspject表示这是一个切面类</code></pre><h3 id="3-1-Order-数字"><a href="#3-1-Order-数字" class="headerlink" title="3.1 @Order(数字)"></a>3.1 @Order(数字)</h3><pre><code>定义切面类的优先级数字越小，优先级越高</code></pre><hr><h3 id="4-声明各种通知"><a href="#4-声明各种通知" class="headerlink" title="4.声明各种通知"></a>4.声明各种通知</h3><pre><code>为需要添加到代理对象中的方法 添加注解**理解思路**：try{    //前置通知    //返回通知}catch(Exception e){    //异常通知}//后置通知</code></pre><h4 id="1-前置通知：-Before-代表作用在被代理的对象方法使用之前"><a href="#1-前置通知：-Before-代表作用在被代理的对象方法使用之前" class="headerlink" title="1.前置通知：@Before:代表作用在被代理的对象方法使用之前"></a>1.前置通知：@Before:代表作用在被代理的对象方法使用之前</h4><pre><code>  如果需要让被代理类的所有方法都被代理，将方法名换成 * 就可以了*举例*: @Before(&quot;execution(public 方法类型 包名.类名.方法名(参数))&quot;)//也可以将&quot;public 方法类型&quot; 换成 * 代表任意修饰符和任意返回值                public void AspectMethod(JoinPoint joinPoint)       {          String methodName = joinPoint.getSignature().getName();          List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs());          System.out.println(&quot;方法名是&quot;+methodName+&quot;参数是&quot;+args);       }</code></pre><h4 id="2-后置通知：-After-代表作用在被代理的对象方法使用之后"><a href="#2-后置通知：-After-代表作用在被代理的对象方法使用之后" class="headerlink" title="2.后置通知：@After:代表作用在被代理的对象方法使用之后"></a>2.后置通知：@After:代表作用在被代理的对象方法使用之后</h4><pre><code>无论过程中有没有发生异常，都会执行后置通知因为可能会出现异常，所以在后置通知中不能访问目标方法执行的结果</code></pre><h4 id="3-返回通知：-AfterReturning"><a href="#3-返回通知：-AfterReturning" class="headerlink" title="3.返回通知：@AfterReturning"></a>3.返回通知：@AfterReturning</h4><pre><code> 可以访问到方法的返回值结果*举例*：@AfterReturning(value = &quot;execution(public 方法类型 包名.类名.方法名(参数))&quot; , returning = &quot;result(返回值名:自定义的)&quot;)     public void afterReturning(JoinPoint joinPoint , Object result)     {         String methodName = joinPoint.getSignature().getName();         System.out.println(&quot;方法名是&quot;+methodName+&quot;参数是&quot;+args+&quot;结果是&quot;+result);     }</code></pre><h4 id="4-异常通知：-AfterThrowing"><a href="#4-异常通知：-AfterThrowing" class="headerlink" title="4.异常通知：@AfterThrowing"></a>4.异常通知：@AfterThrowing</h4><pre><code> 在目标方法出现异常时会执行的代码   可以访问到异常对象，且可以自己指定在出现特定异常时在执行通知代码*举例*：@AfterThrowing(value = &quot;execution(public 方法类型 包名.类名.方法名(参数))&quot; , throwing = &quot;e(异常对象名:自定义的)&quot;)             public void afterThrowing(JoinPoint joinPoint , Exception e)    {         String methodName = joinPoint.getSignature().getName();         System.out.println(&quot;方法名是&quot;+methodName+&quot;参数是&quot;+args+&quot;出现了异常&quot;+e);    }</code></pre><h4 id="5-环绕通知：-Around"><a href="#5-环绕通知：-Around" class="headerlink" title="5.环绕通知：@Around"></a>5.环绕通知：@Around</h4><pre><code> 环绕通知需要携带ProceedingJoinPoint类型的参数 环绕通知类似于动态代理的全过程：参数可以决定是否执行目标方法 环绕通知必须有返回值，返回值即为目标方法的返回值*举例*：@Around(&quot;execution(public 方法类型 包名.类名.方法名(参数))&quot;)        public object aroundMethod(ProceedingJoinPoint pjd)        {           object result = null;           String methodName = pjd.getSignature().getName();           try{                //前置通知                System.out.println(&quot;前置通知&quot;+Arrays.asList(pjd.getArgs()));                //执行目标方法                result = pjd.proceed();                //返回通知                System.out.println(&quot;返回通知&quot;+result);            }           catch(Throwable e)           {                //异常通知                System.out.println(&quot;异常&quot;+e);           }           //后置通知           System.out.println(&quot;后置通知&quot;);        }</code></pre><hr><h2 id="切点表达式的重用"><a href="#切点表达式的重用" class="headerlink" title="切点表达式的重用"></a>切点表达式的重用</h2><pre><code>execution(public 方法类型 包名.类名.方法名(参数))为了代码的复用性提高，避免修改的时候太复杂使用 @Pointcut 自定义一个方法专门用来表示，方法内部什么都不需要写举例：@Pointcut(&quot;execution(public 方法类型 包名.类名.方法名(参数))&quot;)      public void JoinPointExpression(){}     (使用样例) @Before(&quot;类名.JoinPointExpression()&quot;)</code></pre><hr><h1 id="Spring-AOP基于xml配置开发"><a href="#Spring-AOP基于xml配置开发" class="headerlink" title="Spring AOP基于xml配置开发"></a>Spring AOP基于xml配置开发</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a>步骤:</h2><pre><code>1. &lt;!-- 配置bean --&gt;  &lt;bean id = &quot;bean接口类名&quot; class = &quot;包名.bean对象名&quot;&gt;&lt;/bean&gt;  ......2.&lt;!-- 配置切面的bean --&gt;  &lt;bean id = &quot;切面类名&quot;  class = &quot;包.类.切面对象&quot;&gt;&lt;/bean&gt;  ......3.&lt;!-- 配置AOP --&gt;  &lt;aop:config&gt;      &lt;!--配置切面表达式--&gt;      &lt;aop:pointcut expression = &quot;execution(public 方法类型 包名.类名.方法名(参数))&quot; id=&quot;pointcut(自己指定的)&quot;/&gt;      &lt;!--配置切面及通知--&gt;      &lt;aop:aspect ref = &quot;切面类名&quot; order = &quot;数字&quot;&gt;          &lt;aop:before(前置通知) method = &quot;前置方法名&quot; pointcut-ref = &quot;pointcut&quot; /&gt;          &lt;aop:after(后置通知) method = &quot;后置方法名&quot; pointcut-ref = &quot;pointcut&quot; /&gt;          &lt;aop:after-throwing(异常通知) method = &quot;异常方法名&quot; pointcut-ref = &quot;pointcut&quot; throwing = &quot;e&quot; /&gt;          &lt;aop:after-returning(返回通知) method = &quot;返回方法名&quot; pointcut-ref = &quot;pointcut&quot; returning = “result” /&gt;      &lt;/aop:aspect&gt;            &lt;!--环绕通知--&gt;       &lt;aop:aspect ref = &quot;切面类名&quot; order = &quot;数字&quot;&gt;          &lt;aop:around method = &quot;环绕方法名&quot; pointcut-ref = &quot;pointcut&quot; /&gt;      &lt;/aop:aspect&gt;  &lt;/aop:config&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring_IOC和DI</title>
      <link href="/2019/04/13/Spring/Spring_ioc%E4%B8%8Edi/"/>
      <url>/2019/04/13/Spring/Spring_ioc%E4%B8%8Edi/</url>
      
        <content type="html"><![CDATA[<h1 id="spring的概述"><a href="#spring的概述" class="headerlink" title="spring的概述"></a>spring的概述</h1><pre><code>spring: 是java 分层的se/ee的full-stack(一站式) 开源框架        为EE的每一层都提供了解决技术:           web: struts2  springMVC           service: spring(IOC AOP 声明式事务)           dao: hibernate  springJDBCTemplatespring的作用            解耦合        声明式事务        集成junit更加方便的进行分层测试        对优秀框架进行集成            .....</code></pre><a id="more"></a><h1 id="IOC入门"><a href="#IOC入门" class="headerlink" title="IOC入门"></a>IOC入门</h1><p><strong>基本配置</strong></p><h2 id="bean标签-指定要创建的实体类"><a href="#bean标签-指定要创建的实体类" class="headerlink" title="bean标签: 指定要创建的实体类"></a>bean标签: 指定要创建的实体类</h2><pre><code>id属性: 可以为任意值  但是在整个配置文件中唯一class属性: 要实例化类的全限定名 反射 </code></pre><p><strong>scope属性</strong>: 范围<br>        singleton: 单实例 默认值<br>                     如果是单实例,配置文件文件只要一加载  就会创建对象 放在spring容器 (map&lt;id,对象&gt;)<br>                     当所有人过来问spring容器要的时候(getBean),所用人用的都是同一个对象<br>        prototype: 多实例<br>                      如果是多实例,配置文件加载,不创建对象<br>                      当每个人过来getbean的时候,getbean一次创建一次 放在容器中<br>*举例：<br>          <bean id="user" class="User" scope="singleton"></bean><br>          <bean id="user" class="User" scope="prototype"></bean><br>        什么时候用默认值singleton(单实例)? 什么时候用prototype(多实例)?<br>         action: prototype<br>         service/dao: singleton</p><p><strong>了解</strong><br>        singleton的对象什么时候销毁? prototype创建出来的对象什么时候销毁?<br>            ：singleton的对象 当spring容器关闭 对象销毁<br>              prototype的对象 长时间不用自动被垃圾回收机制给回收了</p><pre><code>    init-method:指定初始化方法    destory-method:指定销毁方法    &lt;bean id=&quot;user&quot; class=&quot;User&quot; scope=&quot;prototype&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;&gt;&lt;/bean&gt; </code></pre><h2 id="import标签-导入外部的配置文件"><a href="#import标签-导入外部的配置文件" class="headerlink" title="import标签:导入外部的配置文件"></a>import标签:导入外部的配置文件</h2><pre><code>resource属性:外部配置文件的地址举例：       web:    所有在web层创建的对象       applicationContext_web.xml          service:所有在service层创建的对象   applicationContext_service.xml          dao:    所有在dao层创建的对象       applicationContext_dao.xml          &lt;import resource=&quot;applicationContext_web.xml&quot;/&gt;          &lt;import resource=&quot;applicationContext_service.xml&quot;/&gt;          &lt;import resource=&quot;applicationContext_dao.xml&quot;/&gt;    </code></pre><p>——————————————————————————————————————————————————————————————————————————————————————            </p><h1 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h1><p>首先，了解为什么需要DI</p><ul><li>举例 *：<br>   Car接口中只有run方法，<br>   此时CarIml继承了Car接口并且新加入了属性name<br>   如果只是通过IOC的bean标签创建对象<br>   那么无法给name赋值<br>   因为 Car car = (Car)context.getBean(“car”);<br>   Car接口实际上并没有name属性，无法赋值<br>   此时就需要DI来解决这个问题</li></ul><h1 id="DI的使用："><a href="#DI的使用：" class="headerlink" title="DI的使用："></a>DI的使用：</h1><h2 id="1-set属性注入："><a href="#1-set属性注入：" class="headerlink" title="1.set属性注入："></a>1.set属性注入：</h2><pre><code>第一步：构建setName方法：           在CarIml中构建setName方法第二步: 在applicationContext.xml中bean标签中添加&lt;property&gt;           &lt;property name=&quot;name&quot; value=&quot;兰博基尼&quot;&gt;&lt;/property&gt;     name:要赋值的属性名     value:要赋的值 (针对的是基本类型和String类型)     ref: 针对的是对象类型                指向的是spring中bean的id名     此时当类被创建时，就会自动的初始化name值</code></pre><h2 id="2-构造器注入"><a href="#2-构造器注入" class="headerlink" title="2.构造器注入"></a>2.构造器注入</h2><pre><code>第一步：添加有参构造方法第二部：在applicationContext.xml中bean标签中添加&lt;constructor-arg&gt;          name:要赋值的属性名          value:要赋的值 (针对的是基本类型和String类型)          ref: 针对的是对象类型      &lt;constructor-arg name=&quot;name&quot; value=&quot;BMW&quot;&gt;&lt;/constructor-arg&gt;</code></pre><h2 id="3-P名称空间注入"><a href="#3-P名称空间注入" class="headerlink" title="3.P名称空间注入"></a>3.P名称空间注入</h2><pre><code>底层：set注入（所以还是需要有set方法）条件: 在配置文件中有p的名称空间      xmlns:p=&quot;http://www.springframework.org/schema/p&quot;语法:&lt;bean p:属性名=&quot;属性值&quot; p:属性名-ref=&quot;bean的id对象值&quot; &gt;&lt;bean id=&quot;person&quot; class=&quot;CarImpl&quot; p:name=&quot;BMW&quot; p:car-ref=&quot;car&quot;&gt;&lt;/bean&gt;</code></pre><h2 id="4-复杂属性注入-map-list-等"><a href="#4-复杂属性注入-map-list-等" class="headerlink" title="4.复杂属性注入:map,list[]等"></a>4.复杂属性注入:map,list[]等</h2><pre><code>    &lt;bean id=&quot;collBean&quot; class=&quot;CollBean&quot;&gt;    &lt;property name=&quot;ArrayDemo&quot;&gt;        &lt;!-- 数组类型 --&gt;        &lt;list&gt;            &lt;value&gt;aaa&lt;/value&gt;            &lt;value&gt;bbb&lt;/value&gt;            &lt;value&gt;ccc&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;property name=&quot;listDemo&quot;&gt;        &lt;!-- list类型  --&gt;        &lt;list&gt;            &lt;value&gt;111&lt;/value&gt;            &lt;value&gt;222&lt;/value&gt;            &lt;ref bean=&quot;car&quot;/&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;property name=&quot;mapDemo&quot;&gt;        &lt;!-- map --&gt;        &lt;map&gt;            &lt;entry key=&quot;k1&quot; value=&quot;aaa&quot;&gt;&lt;/entry&gt;            &lt;entry key=&quot;k2&quot; value=&quot;bbbb&quot;&gt;&lt;/entry&gt;            &lt;entry key=&quot;k3&quot; value-ref=&quot;car&quot;&gt;&lt;/entry&gt;        &lt;/map&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><hr><h1 id="Spring的ioc注解入门"><a href="#Spring的ioc注解入门" class="headerlink" title="Spring的ioc注解入门"></a>Spring的ioc注解入门</h1><h2 id="注解的开发步骤"><a href="#注解的开发步骤" class="headerlink" title="注解的开发步骤:"></a>注解的开发步骤:</h2><pre><code>1.导包  spring-aop.jar2.开启注解扫描器  告诉spring应该去那个包下面解析注解3.配置注解组件  Component4.测试</code></pre><h2 id="掌握的注解"><a href="#掌握的注解" class="headerlink" title="掌握的注解"></a>掌握的注解</h2><pre><code>注解条件:(掌握)    1 导包 spring-aop.jar    2 配置注解扫描器        &lt;context:component-scan base-package=&quot;自己的包&quot;&gt;&lt;/context:component-scan&gt;</code></pre><hr><h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><pre><code> 等同于&lt;bean id=&quot;&quot; class=&quot;&quot;&gt;&lt;/bean&gt;(&quot;bean的id值&quot;) 定义在类上 只要定义在了类上，那么注解扫描器只要一扫描到就会创建该类的实例对象 放在spring容器中。spring发布了公告, @Component这个注解不维护了,要维护这个注解下面衍生出的3个注解</code></pre><h4 id="Controller-“bean的id值”-针对的就是web层"><a href="#Controller-“bean的id值”-针对的就是web层" class="headerlink" title="@Controller(“bean的id值”) 针对的就是web层"></a>@Controller(“bean的id值”) 针对的就是web层</h4><h4 id="Service-“bean的id值”-针对的是service层"><a href="#Service-“bean的id值”-针对的是service层" class="headerlink" title="@Service(“bean的id值”)    针对的是service层"></a>@Service(“bean的id值”)    针对的是service层</h4><h4 id="Repository-“bean的id值”-针对的是dao层"><a href="#Repository-“bean的id值”-针对的是dao层" class="headerlink" title="@Repository(“bean的id值”) 针对的是dao层"></a>@Repository(“bean的id值”) 针对的是dao层</h4><hr><h3 id="Value-“属性值”"><a href="#Value-“属性值”" class="headerlink" title="@Value(“属性值”)"></a>@Value(“属性值”)</h3><pre><code>定义在属性字段上 针对的是基本类型和String类型如果使用了这个注解,该属性的set方法可以省略不写</code></pre><hr><h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><pre><code>定义在属性字段上的 针对的是对象类型如果定义在了那个对象类型的属性身上 会自动去spring容器中找该类型的实例对象给赋值</code></pre><hr><h3 id="Qualifier-“userDaoxxx”"><a href="#Qualifier-“userDaoxxx”" class="headerlink" title="@Qualifier(“userDaoxxx”)"></a>@Qualifier(“userDaoxxx”)</h3><pre><code>定义在属性字段上的 指定用该类型的哪个id名称的实例对象注意: @Qualifier要想使用 必须结合 @Autowired 一起使用</code></pre><hr><h3 id="Resource-name-”userDaoxxx”"><a href="#Resource-name-”userDaoxxx”" class="headerlink" title="@Resource(name=”userDaoxxx”)"></a>@Resource(name=”userDaoxxx”)</h3><pre><code>等同于：@Autowired+@Qualifier(&quot;userDaoxxx&quot;)</code></pre><hr><h2 id="了解的注解"><a href="#了解的注解" class="headerlink" title="了解的注解:"></a>了解的注解:</h2><pre><code>@Scope(&quot;singleton&quot;或prototype)  定义在类上的 指定当前类是单实例还是多实例@PostConstruct  定义在方法上  配置初始化方法@PreDestroy     定义在方法上 配置销毁的方法</code></pre><hr><h2 id="Spring全注解开发"><a href="#Spring全注解开发" class="headerlink" title="Spring全注解开发"></a>Spring全注解开发</h2><pre><code> @Configuration // 表示该类是一个注解类 @ComponentScan(basePackages=&quot;包名&quot;)      **等于**  &lt;context:component-scan base-package=&quot;包名&quot;&gt;&lt;/context:component-scan&gt; @PropertySource(value=&quot;classpath:jdbc.properties&quot;)    **等于**  &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; @Bean(name=&quot;c3p0&quot;)      **等于**  &lt;bean id=&quot;c3p0&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;    获得Spring对象 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class)</code></pre><p><em>全注解开发目前比半xml半注解开发麻烦，据说企业用的较少，所以我笔记就学到了这里</em></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>servlet入门笔记</title>
      <link href="/2019/02/24/JavaWeb/servlet%E5%85%A5%E9%97%A8/"/>
      <url>/2019/02/24/JavaWeb/servlet%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Servlet接口实现类"><a href="#Servlet接口实现类" class="headerlink" title="Servlet接口实现类"></a>Servlet接口实现类</h1> <a id="more"></a><p>1、Servlet接口的默认实现类，分别为：GenericServlet、HttpServlet。<br><!-- more --><br>2、HttpServlet指能够处理HTTP请求的servlet，它在原有Servlet接口上添加了一些与HTTP协议处理方法，它比Servlet接口的功能更为强大。因此开发人员在编写Servlet时，通常应继承这个类，而避免直接去实现Servlet接口。</p><p>3、HttpServlet在实现Servlet接口时，覆写了service方法，该方法体内的代码会自动判断用户的请求方式，如为GET请求，则调用HttpServlet的doGet方法，如为Post请求，则调用doPost方法。因此，开发人员在编写Servlet时，通常只需要覆写doGet或doPost方法，而不要去覆写service方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">httpservlet//重载了service方法</span><br><span class="line">&#123;</span><br><span class="line">service()&#123;</span><br><span class="line">//获取请求方式</span><br><span class="line">//根据请求方式的不同 调用do***方法</span><br><span class="line">&#125;</span><br><span class="line">do***方法()&#123;</span><br><span class="line">//接收请求</span><br><span class="line">//处理请求</span><br><span class="line">//返回响应</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DemoServlet extend httpservlet</span><br><span class="line">&#123;</span><br><span class="line">do***()//重写&#123;</span><br><span class="line">//接收请求</span><br><span class="line">//处理请求</span><br><span class="line">//返回响应</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置"></a>web.xml配置</h1><h2 id="servlet类名配置"><a href="#servlet类名配置" class="headerlink" title="servlet类名配置"></a>servlet类名配置</h2><p>  <servlet><br>    <servlet-name> </servlet-name><br>    <servlet-class> </servlet-class><br>  </servlet></p><h2 id="路径配置"><a href="#路径配置" class="headerlink" title="路径配置"></a>路径配置</h2><pre><code>&lt;servlet-mapping&gt;&lt;servlet-name&gt;CookieServlet&lt;/servlet-name&gt;&lt;url-pattern&gt;/ck&lt;/url-pattern&gt;</code></pre><p>  <br><em>路径常见问题</em><br>假设有多个servlet<br>1.<url-pattern>/aa/bb</url-pattern><br>2.<url-pattern>/aa/<em></em></url-pattern><br>此时访问/aa/bb,就会运行第一个servlet，因为默认最精准的优先<br>此时访问/aa/,就会运行第二个<br>如果两个路径相同，那么直接会报错</p>]]></content>
      
      
      <categories>
          
          <category> JAVAEE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/2019/02/03/JavaSe/JDBC/ThreadLocal/"/>
      <url>/2019/02/03/JavaSe/JDBC/ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadLocal-线程局部变量"><a href="#ThreadLocal-线程局部变量" class="headerlink" title="ThreadLocal:线程局部变量"></a>ThreadLocal:线程局部变量</h1><a id="more"></a><ul><li>作用：为每一个线程，提供一个存储数据空间</li><li><p>底层：ThreadLocal类实际上内部封装了一个Map集合</p><pre><code>  Map&lt;Thread,Object&gt;ThreadLocal有两个方法：| get();//以当前线程对象作为键，从类内部的Map中获取值|        (实际上：map.get(Thread.cruuentThread());)|        | set(Object obj);//以当前线程对象作为键，设置值保存到map集合</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVASE之JDBC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>QueryRunner</title>
      <link href="/2019/02/02/JavaSe/JDBC/QueryRunner/"/>
      <url>/2019/02/02/JavaSe/JDBC/QueryRunner/</url>
      
        <content type="html"><![CDATA[<h1 id="关于QueryRunner的查询功能"><a href="#关于QueryRunner的查询功能" class="headerlink" title="关于QueryRunner的查询功能"></a>关于QueryRunner的查询功能</h1><a id="more"></a><p>  步骤<br>  1.QueryRunner(DataSource)<br>  2.query(String sql,ResultSetHandler<t> rsh,Object…params);</t></p><p><em>**</em> ResultSetHandler:结果集处理类(接口)<br>      |BeanHandler:将结果集中第一条记录封装到一个指定的javaBean中<br>      |BeanListHandler:将结果集中每一条记录封装到指定的javaBean中，<br>      |                将这些javaBean在封装到List集合中。<br>      |ScalarHandler:它是用于单个数据，例如：select count(*)from </p><p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><ul><li>此代码演示了ResultSetHandler的九种结果集实现类</li><li>重点常用的是</li><li>BeanHandler()//将结果集中第一条记录封装到一个指定的javaBean中</li><li>BeanLiatHandler()//将结果集中每一条记录封装到指定的javaBean中，</li><li>将这些javaBean在封装到List集合中。</li><li>ScalarHandle()//查询某个数据的个数</li><li>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">public class QueryRunnerDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws SQLException &#123;</span><br><span class="line">        //ArrayHandlerTest();//将第一条数据保存到Object数组中并返回</span><br><span class="line">        //ArrayListHandlerTest();//返回的是集合封装好的一个一个的数组</span><br><span class="line">        //BeanHandlerTest();//将结果集中第一条记录封装到一个指定的javaBean中</span><br><span class="line">        //BeanLiatHandlerTest();//将结果集中每一条记录封装到指定的javaBean中，将这些javaBean在封装到List集合中。</span><br><span class="line">        //ColumnListHandlerTest();//将某一列封装成集合并返回</span><br><span class="line">        //MapHandlerTest();//将结果封装成map集合并返回</span><br><span class="line">        //MapListHandlerTest();</span><br><span class="line">        //ScalarHandleTest();</span><br><span class="line">        //KeyedHandler();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void ArrayHandlerTest() throws SQLException &#123;</span><br><span class="line">        //将第一条数据保存到Object数组中并返回</span><br><span class="line">        //如果SQL语句中没有规定查询第几个数据，就会默认保存了第一条数据(该例中就是cid=1的数据)</span><br><span class="line">        QueryRunner qr = new QueryRunner(C3P0Utils.getDataSource());</span><br><span class="line">        String sql = &quot;SELECT * from category where cid = ?&quot;;</span><br><span class="line">        Object[] obj = &#123;3&#125;;</span><br><span class="line">        Object[] os = qr.query(sql,new ArrayHandler(),obj);</span><br><span class="line">        for(Object objects:os)&#123;</span><br><span class="line">            System.out.println(objects);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void ArrayListHandlerTest() throws SQLException &#123;</span><br><span class="line">        //当SQL语句要查询多个或所有的数据</span><br><span class="line">        //ArrayListHandler返回值是List&lt;Object[]&gt;类型，返回的是集合封装好的一个一个的数组</span><br><span class="line">        //所以输出的时候也要规定好数组的下标</span><br><span class="line">        QueryRunner qr = new QueryRunner(C3P0Utils.getDataSource());</span><br><span class="line">        String sql = &quot;SELECT * from category&quot;;</span><br><span class="line">        Object[] obj = &#123;3&#125;;</span><br><span class="line">        List&lt;Object[]&gt; list = qr.query(sql,new ArrayListHandler());</span><br><span class="line">        for(Object[] objects:list)&#123;</span><br><span class="line">            System.out.println(objects[0]+&quot;  &quot;+objects[1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void BeanHandlerTest() throws SQLException &#123;</span><br><span class="line">        //BeanHandler类将结果集中第一条记录封装到一个指定的javaBean中</span><br><span class="line">        //用来查询一个值，并且将该值封装成一个对象并返回</span><br><span class="line">        QueryRunner qr = new QueryRunner(C3P0Utils.getDataSource());</span><br><span class="line">        String sql = &quot;SELECT * from category&quot;;</span><br><span class="line">        Category c = qr.query(sql,new BeanHandler&lt;Category&gt;(Category.class));//BeanHandler类的使用</span><br><span class="line">        System.out.println(c);//此处就只有第一条数据</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void BeanLiatHandlerTest() throws SQLException &#123;</span><br><span class="line">        //BeanListHandler类将所有结果封装到指定的javaBean中</span><br><span class="line">        //并将这些javabean封装成集合并返回</span><br><span class="line">        QueryRunner qr = new QueryRunner(C3P0Utils.getDataSource());</span><br><span class="line">        String sql = &quot;SELECT * from category&quot;;</span><br><span class="line">        List&lt;Category&gt; c = qr.query(sql,new BeanListHandler&lt;Category&gt;(Category.class));</span><br><span class="line">        for(Category category : c)&#123;</span><br><span class="line">            System.out.println(category);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void ColumnListHandlerTest() throws SQLException &#123;</span><br><span class="line">        //ColumnListHandler类将指定的某一列的数据封装到集合中并返回</span><br><span class="line">        QueryRunner qr = new QueryRunner(C3P0Utils.getDataSource());</span><br><span class="line">        String sql = &quot;SELECT * from category&quot;;</span><br><span class="line">        List list = qr.query(sql,new ColumnListHandler&lt;&gt;(&quot;cname&quot;));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void MapHandlerTest() throws SQLException &#123;</span><br><span class="line">        //返回MAP集合</span><br><span class="line">        QueryRunner qr = new QueryRunner(C3P0Utils.getDataSource());</span><br><span class="line">        String sql = &quot;SELECT * from category&quot;;</span><br><span class="line">        Map&lt;String,Object&gt; m = qr.query(sql,new MapHandler());</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void MapListHandlerTest() throws SQLException &#123;</span><br><span class="line">        QueryRunner qr = new QueryRunner(C3P0Utils.getDataSource());</span><br><span class="line">        String sql = &quot;SELECT * from category&quot;;</span><br><span class="line">        List&lt;Map&lt;String,Object&gt;&gt; m = qr.query(sql,new MapListHandler());</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void ScalarHandleTest() throws SQLException &#123;</span><br><span class="line">        //查询某个数据的个数</span><br><span class="line">        QueryRunner qr = new QueryRunner(C3P0Utils.getDataSource());</span><br><span class="line">        String sql = &quot;SELECT count(*) from category&quot;;</span><br><span class="line">        //此处的返回值是long,因为数据库的数据太多，这里默认是Long而不是Integer</span><br><span class="line">        Long count = qr.query(sql,new ScalarHandler&lt;Long&gt;());</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void KeyedHandler() throws SQLException &#123;</span><br><span class="line">        //查询的每一行数据存储到map集合中,将多个map集合再存储到map中</span><br><span class="line">        QueryRunner qr = new QueryRunner(C3P0Utils.getDataSource());</span><br><span class="line">        String sql = &quot;SELECT * FROM category&quot;;</span><br><span class="line">        Map&lt;Object, Map&lt;String, Object&gt;&gt; map = qr.query(sql, new KeyedHandler&lt;&gt;());</span><br><span class="line">        //遍历map(两层)</span><br><span class="line">        for(Object obj : map.keySet()) &#123;</span><br><span class="line">            for(String key : map.get(obj).keySet()) &#123;</span><br><span class="line">                System.out.print(key+&quot;\t&quot;+map.get(obj).get(key)+&quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVASE之JDBC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DBCP连接池</title>
      <link href="/2019/02/01/JavaSe/JDBC/DBCP%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
      <url>/2019/02/01/JavaSe/JDBC/DBCP%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="DBCP连接池"><a href="#DBCP连接池" class="headerlink" title="DBCP连接池"></a>DBCP连接池</h1><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 所有的连接池必须遵循 javax.sql.DataSource接口</span><br><span class="line"> * </span><br><span class="line"> * 在DBCP连接池中</span><br><span class="line"> * 实现 javax.sql.DataSource接口的实现类是:</span><br><span class="line"> *  BasicDataSource</span><br><span class="line"> * 使用:</span><br><span class="line"> * 创建BasicDataSource对象,并且给他设置数据库连接的四大要素即可</span><br><span class="line"> * private static BasicDataSource ds = new BasicDataSource();</span><br><span class="line"> * //设置数据库连接四大要素</span><br><span class="line"> * ds.setDriverClassName(driverName);</span><br><span class="line"> * ds.setUrl(url);</span><br><span class="line"> * ds.setUsername(username);</span><br><span class="line"> * ds.setPassword(password);</span><br><span class="line"> * 带有配置文件的DBCP的使用</span><br><span class="line"> * 核心类:BasicDataSourceFactory(工厂)</span><br><span class="line"> *  public static DataSource createDataSource(Properties对象);</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class DBCPUtils &#123;</span><br><span class="line">//private static String driverName = &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class="line">//private static String url = &quot;jdbc:mysql://localhost:3306/day04&quot;;</span><br><span class="line">//private static String username = &quot;root&quot;;</span><br><span class="line">//private static String password = &quot;123&quot;;</span><br><span class="line"></span><br><span class="line">private static DataSource ds = null;</span><br><span class="line">//静态代码块,设置ds的四大要素</span><br><span class="line">static&#123;</span><br><span class="line">try &#123;</span><br><span class="line">Properties ps = new Properties();</span><br><span class="line"></span><br><span class="line">//两种配置方法(建议第二种)</span><br><span class="line">//ps.load(new FileInputStream(&quot;D:\\JAVA\\DBCP\\dbcpconfig.properties&quot;));</span><br><span class="line">ps.load(DBCPUtils.class.getClassLoader().getResourceAsStream(&quot;dbcpconfig.properties&quot;));</span><br><span class="line"></span><br><span class="line">ds = BasicDataSourceFactory.createDataSource(ps);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">//ds.setDriverClassName(driverName);</span><br><span class="line">//ds.setUrl(url);</span><br><span class="line">//ds.setUsername(username);</span><br><span class="line">//ds.setPassword(password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Connection getConnection() throws SQLException &#123;</span><br><span class="line">//返回一个连接对象,不要用DriverManager获取,而是连接池中获取</span><br><span class="line">return ds.getConnection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//关闭所有资源的统一代码</span><br><span class="line">public static void closeAll(Connection conn, Statement st, ResultSet rs)&#123;</span><br><span class="line">//负责关闭</span><br><span class="line">if(conn != null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(st != null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">st.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(rs != null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVASE之JDBC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C3P0连接池</title>
      <link href="/2019/02/01/JavaSe/JDBC/C3P0%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
      <url>/2019/02/01/JavaSe/JDBC/C3P0%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="C3P0连接池"><a href="#C3P0连接池" class="headerlink" title="C3P0连接池"></a>C3P0连接池</h1><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在C3P0连接池中 遵循了javax.sql.DataSource接口的实现类:</span><br><span class="line"> * ComboPooledDataSource</span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * @author yingpeng</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class C3P0Utils02 &#123;</span><br><span class="line"></span><br><span class="line">private static ComboPooledDataSource ds = new ComboPooledDataSource();</span><br><span class="line"></span><br><span class="line">//static代码块设置数据库连接四大要素</span><br><span class="line"></span><br><span class="line">public static Connection getConnection() throws SQLException&#123;</span><br><span class="line">//获取连接,不要自己去DriverManager获取,而是从C3P0连接池获取</span><br><span class="line">return ds.getConnection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//关闭所有资源的统一代码</span><br><span class="line">public static void closeAll(Connection conn,Statement st,ResultSet rs)&#123;</span><br><span class="line">//负责关闭</span><br><span class="line">if(conn != null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(st != null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">st.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(rs != null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVASE之JDBC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事务</title>
      <link href="/2019/02/01/JavaSe/JDBC/JDBC%E5%A4%84%E7%90%86%E4%BA%8B%E5%8A%A1/"/>
      <url>/2019/02/01/JavaSe/JDBC/JDBC%E5%A4%84%E7%90%86%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>#事务<br><a id="more"></a></p><h2 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1.什么是事务？"></a>1.什么是事务？</h2><pre><code>举例：在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，这样，这些数据库操作语句就构成一个事务！</code></pre><h2 id="2-事务是必须满足4个条件（ACID）"><a href="#2-事务是必须满足4个条件（ACID）" class="headerlink" title="2.事务是必须满足4个条件（ACID）"></a>2.事务是必须满足4个条件（ACID）</h2><p><em>原子性</em>：一组事务，要么成功；要么撤回。</p><p><em>一致性</em>：事务执行后，数据库状态与其他业务规则保持一致。<br>        如转账业务，无论事务执行成功否，参与转账的两个账号余额之和应该是不变的。</p><p><em>隔离性</em>：事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。<br>        事务的100%隔离，需要牺牲速度。</p><p><em>持久性</em>：软、硬件崩溃后，InnoDB数据表驱动会利用日志文件重构修改。可靠性和高速度不可兼得，<br>        innodb_flush_log_at_trx_commit 选项 决定什么时候吧事务保存到日志里。</p><h2 id="3-JDBC中的事务"><a href="#3-JDBC中的事务" class="headerlink" title="3.JDBC中的事务"></a>3.JDBC中的事务</h2><p><em>setAutoCommit(boolean)</em>:<br>    设置是否为自动提交事务，<br>    如果true（默认值为true）表示自动提交，也就是每条执行的SQL语句都是一个单独的事务，<br>    如果设置为false，那么相当于开启了事务了；con.setAutoCommit(false) 表示开启事务。<br><em>commit()</em>：提交结束事务。<br><em>rollback()</em>：回滚结束事务。</p><p>格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">     con.setAutoCommit(false);//开启事务</span><br><span class="line">     ......</span><br><span class="line">     con.commit();//try的最后提交事务      </span><br><span class="line"> &#125; catch（） &#123;</span><br><span class="line">     con.rollback();//回滚事务</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="4、并发事务问题"><a href="#4、并发事务问题" class="headerlink" title="4、并发事务问题"></a>4、并发事务问题</h2><p>因为并发事务导致的问题大致有5类，其中两类是更新问题三类是读问题。</p><p><strong>脏读</strong>（dirty read）：读到另一个事务的未提交新数据，即读取到了脏数据；<br><strong>不可重复读</strong>（unrepeatable）：对同一记录的两次读取不一致，因为另一事务对该记录做了修改；<br><strong>幻读（虚读）</strong>（phantom read）：对同一张表的两次查询不一致，因为另一事务插入了一条记录。</p><h2 id="5、四大隔离级别"><a href="#5、四大隔离级别" class="headerlink" title="5、四大隔离级别"></a>5、四大隔离级别</h2><pre><code>4个等级的事务隔离级别，在相同的数据环境下，使用相同的输入，执行相同的工作，根据不同的隔离级别，可以导致不同的结果。不同事务隔离级别能够解决的数据并发问题的能力是不同的。</code></pre><h3 id="1、SERIALIZABLE-串行化"><a href="#1、SERIALIZABLE-串行化" class="headerlink" title="1、SERIALIZABLE(串行化)"></a>1、SERIALIZABLE(串行化)</h3><p>不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的；<br>性能最差</p><h3 id="2、REPEATABLE-READ-可重复读-（MySQL）"><a href="#2、REPEATABLE-READ-可重复读-（MySQL）" class="headerlink" title="2、REPEATABLE READ(可重复读)（MySQL）"></a>2、REPEATABLE READ(可重复读)（MySQL）</h3><p>防止脏读和不可重复读，不能处理幻读<br>性能比SERIALIZABLE好</p><h3 id="3、READ-COMMITTED-读已提交数据-（Oracle）"><a href="#3、READ-COMMITTED-读已提交数据-（Oracle）" class="headerlink" title="3、READ COMMITTED(读已提交数据)（Oracle）"></a>3、READ COMMITTED(读已提交数据)（Oracle）</h3><p>防止脏读，不能处理不可重复读和幻读；<br>性能比REPEATABLE READ好</p><h3 id="4、READ-UNCOMMITTED-读未提交数据"><a href="#4、READ-UNCOMMITTED-读未提交数据" class="headerlink" title="4、READ UNCOMMITTED(读未提交数据)"></a>4、READ UNCOMMITTED(读未提交数据)</h3><p>可能出现任何事物并发问题，什么都不处理。<br>性能最好</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE之JDBC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Batch</title>
      <link href="/2019/02/01/JavaSe/JDBC/%E6%89%B9%E5%A4%84%E7%90%86Batch/"/>
      <url>/2019/02/01/JavaSe/JDBC/%E6%89%B9%E5%A4%84%E7%90%86Batch/</url>
      
        <content type="html"><![CDATA[<h1 id="批处理：Batch"><a href="#批处理：Batch" class="headerlink" title="批处理：Batch"></a>批处理：Batch</h1><a id="more"></a><p>   *对于大量的批处理，建议使用Statement,<br>    因为PreparedStatement的预编译空间有限<br>    当数据量特别大时，会发生异常</p><pre><code>*************************************//示例：批处理插入1000个数据{    ......    conn.setAutoCommit(false);//将自动提交事务的功能 关闭    long start = System.currentTimeMillis();    Statement stmt = conn.createStatement();    for(int i = 10;i&lt;=1000;i++)    {        stmt.addBatch(&quot;insert into students (sid,NAME,sage) values (&quot;+i+&quot;,&apos;哈哈&quot;+i+&quot;&apos;,11)&quot;);    }    stmt.executeBatch();    conn.commit();//提交事务    long end = System.currentTimeMillis();    System.out.println(&quot;time:&quot;+ (end - start));}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVASE之JDBC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ResultSet接口</title>
      <link href="/2019/02/01/JavaSe/JDBC/ResultSet%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/02/01/JavaSe/JDBC/ResultSet%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="ResultSet接口："><a href="#ResultSet接口：" class="headerlink" title="ResultSet接口："></a>ResultSet接口：</h1><pre><code>使用PreparedStatement的executeQuery()方法，返回Result对象</code></pre><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//演示2.查询数据</span><br><span class="line">            String sql2 = &quot;SELECT sid,NAME,sage FROM students WHERE sid &gt; ?&quot;;</span><br><span class="line">            pst2 = conn.prepareStatement(sql2);</span><br><span class="line">            pst2.setInt(1,2);//将sid大于2的值取出来</span><br><span class="line">            rs = pst2.executeQuery();</span><br><span class="line">            //通过ResultSet的next的方法进行迭代</span><br><span class="line">            while(rs.next())</span><br><span class="line">            &#123;   //Result的getxxxx方法中输入数字，代表要打印第几列</span><br><span class="line">                System.out.println(rs.getInt(1)+rs.getString(2)+rs.getString(3));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">******切记要关闭   关闭顺序是 从后往前关闭</span><br><span class="line">//关闭ResultSet</span><br><span class="line">            try&#123;</span><br><span class="line">                if(rs!=null) &#123;</span><br><span class="line">                    rs.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;catch (SQLException re)</span><br><span class="line">            &#123;</span><br><span class="line">                re.printStackTrace();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVASE之JDBC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PreparedStatement接口</title>
      <link href="/2019/02/01/JavaSe/JDBC/PreparedStatement%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/02/01/JavaSe/JDBC/PreparedStatement%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="PreparedStatement接口"><a href="#PreparedStatement接口" class="headerlink" title="PreparedStatement接口"></a>PreparedStatement接口</h1><a id="more"></a><p> 继承于Statement<br> 但是却拥有更安全更高效率的方法</p><p>具体如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 此代码演示了PreparedStatement类</span><br><span class="line"> * */</span><br><span class="line">public class PreparedStatementDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            Connection conn =</span><br><span class="line">                    DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/demo?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT&quot;, &quot;root&quot;, &quot;wangxv123&quot;);</span><br><span class="line">            // 此处的 ? 是代表占位符</span><br><span class="line">            //为了避免SQL的风险，PreparedStatement中使用占位符来先保证参数</span><br><span class="line">            String sql = &quot;INSERT INTO students (sid,NAME,sage) VALUES (?,?,?);&quot;;</span><br><span class="line">            PreparedStatement pst = conn.prepareStatement(sql);</span><br><span class="line">            //然后在使用set****等各种方法给参数赋值，因为规定了类型，所以可以避免SQL注入的风险</span><br><span class="line">            pst.setInt(1,006);</span><br><span class="line">            pst.setString(2,&quot;哈哈&quot;);</span><br><span class="line">            pst.setInt(3,22);</span><br><span class="line"> //也可以使用  pst.setObject   此方法的好处是不需要知道具体类型</span><br><span class="line">            pst.execute();</span><br><span class="line"></span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;finally</span><br><span class="line">        &#123;   </span><br><span class="line">            //关闭PreparedStatement</span><br><span class="line">            try&#123;</span><br><span class="line">                if(pst!=null) &#123;</span><br><span class="line">                    pst.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;catch (SQLException se)</span><br><span class="line">            &#123;</span><br><span class="line">                se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            //关闭Connect</span><br><span class="line">            try &#123;</span><br><span class="line">                if(conn!=null)</span><br><span class="line">                &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;catch (SQLException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JAVASE之JDBC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Stamement接口</title>
      <link href="/2019/02/01/JavaSe/JDBC/Statement%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/02/01/JavaSe/JDBC/Statement%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Stamement接口"><a href="#Stamement接口" class="headerlink" title="Stamement接口"></a>Stamement接口</h1><ul><li>用于执行静态SQL语句并返回它生成结果的对象。<a id="more"></a></li><li>三种Stamement：<pre><code>*Stamement：用createStatement创建，用于发送简单的SQL语句。(不带参数）*PreparedStatement:            继承自Statement接口，由prepareStatement创建，用于发送含有            一个或多个输入参数的SQL语句。             (PreparedStatement对象比Statement对象的效率更高            并且可以防止SQL注入，通常都使用这个。)*CallableStatement:            继承自PreparedStatement,由方法prePareCall创建            用于调用存储过程。</code></pre></li><li>常用的Statement方法：<pre><code>*execute():运行语句，返回是否有结果集。*executeQuery():运行select语句，返回ResultSET结果集。*executeUpdate():运行insert/update/delete操作，返回更新的行数。</code></pre></li></ul><p><strong>***</strong>代码样例<strong><em>**</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class jdbcDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;   </span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);            </span><br><span class="line">            Connection conn =</span><br><span class="line">                    DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/demo?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT&quot;, &quot;root&quot;, &quot;wangxv123&quot;);         </span><br><span class="line">            //创建Statement对象</span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line">//输入SQL语句操作数据库</span><br><span class="line">            stmt.execute(&quot;UPDATE students SET sage = 40 WHERE NAME=&apos;王五&apos;;# sid = 2&quot;);</span><br><span class="line">/*//Statement风险：SQL注入</span><br><span class="line">     String id = &quot;5 or 1=1&quot;;</span><br><span class="line">             String sql = &quot;delete from demo where id =&quot;+id;</span><br><span class="line">             stmt.execute(sql);</span><br><span class="line">             //通过输入恒等式执行execute，删除了所有的数据</span><br><span class="line">             */</span><br><span class="line">         </span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;finally</span><br><span class="line">        &#123;   //关闭Statement</span><br><span class="line">            try&#123;</span><br><span class="line">                if(stmt !=null) &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;catch (SQLException se)</span><br><span class="line">            &#123;</span><br><span class="line">                se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            //关闭Connect</span><br><span class="line">            try &#123;</span><br><span class="line">                if(conn!=null)</span><br><span class="line">                &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;catch (SQLException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JAVASE之JDBC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JDBC连接数据库</title>
      <link href="/2019/02/01/JavaSe/JDBC/JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/02/01/JavaSe/JDBC/JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>连接MYSQL数据库<br>    Connection con =<br>    DriverManager.getConnection(“jdbc:mysql;//host:port/database”,”user”,”password”);<br>    …<br>    <a id="more"></a><br>/**</p><ul><li>此代码演示通过JDBC连接数据库</li><li>*/<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class jdbcDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;   //加载驱动类</span><br><span class="line">            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">            //建立连接(连接对象内部其实包含了Socket对象，是一个远程的连接。比较耗时，这是Connection对象管理的要点）</span><br><span class="line">            //真正开发中都是通过连接池来管理连接对象</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            Connection conn =</span><br><span class="line">                    DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/demo?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT&quot;, &quot;root&quot;, &quot;wangxv123&quot;);</span><br><span class="line">            long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;time:&quot;+ (end - start));</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong><strong><strong><em>**</em></strong></strong></strong>错误详解<br><em>错误1：加载类“com.mysql.jdbc.Driver” 。这已被弃用。</em></p><p>  解决方法：<br>      新的驱动程序类是`com.mysql.cj.jdbc.Driver’</p><p><em>错误2：Sat Jun 02 11:40:45 CST 2018 WARN：建议不建立服务器身份验证的SSL连接。</em><br>  根据MySQL 5.5.45 +，5.6.26 +和5.7.6+的要求，如果未设置显式选项，则必须默认建立SSL连接。<br>  为了符合不使用SSL的现有应用程序，verifyServerCertificate属性设置为’false’。<br>  您需要通过设置useSSL = false显式禁用SSL，或者设置useSSL = true并且为服务器证书验证提供信任库。</p><p>  解决方法：<br>      这是一个警告<br>      即在原来的数据库名称后面添加：?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</p><p><em>错误3：<br>    java.sql.SQLException中：服务器时区值’??? EE×??±??’ 。</em></p><p>   解决方法：<br>     这是由于数据库和系统时区差异所造成的，<br>     在JDBC连接的URL后面加上serverTimezone = GMT即可解决问题，<br>     再一个解决办法就是使用低版本的MySQL jdbc驱动，</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE之JDBC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2019/01/15/JavaSe/%E5%8F%8D%E5%B0%84/"/>
      <url>/2019/01/15/JavaSe/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>   JAVA反射机制是在运行状态中，<br>   对于任意一个类，都能够知道这个类的所有属性的方法；<br>   对于任意一个对象，都能够调用它的任意一个方法和属性；<br>   这种动态获取的信息以及动态调用对象的方法的功能称为JAVA语言的发射机制</p><p>   动态获取类中信息，就是JAVA反射，可以理解为对类的解剖。<br>…<br><a id="more"></a></p><hr><h1 id="Class-字节码文件类"><a href="#Class-字节码文件类" class="headerlink" title="Class:字节码文件类"></a>Class:字节码文件类</h1><ul><li>想要获得一个类的Class对象，有三种方法<br>//////////////////////////////////////////////////////////////////////////<br>   //1.Object类中的getClass()方法的<br>  //想要用这种方式，必须要明确具体的类，并创建对象。<br>  public static void getClassObject1 ()<br>  {<pre><code>Student p = new Student();Class class1 = p.getClass();</code></pre>  }<br>//////////////////////////////////////////////////////////////////////////<br>  //2.任何数据类型都具备一个静态的属性.class来获取其对应的Class对象<br>  //相对1来说更简单，但还是需要明确用到类中的静态成员。<br>  private static void getClassObject2 ()<br>  {<pre><code>Class class2 = Student.class;</code></pre>  }<br>////////////////////////////////////////////////////////////////////////////<br>  //3.只要通过给定的类的字符串名称就可以获取该类，更为扩展<br>  //可以用Class类中的方法完成，该方法就是forName<br>  public static void getClassObject3 ()<br>  {<pre><code>String className = &quot;test.Student&quot;;Class class3 = null;try {    //找寻该名称类文件，并加载进内存，并产生Class对象    class3 = Class.forName(className);} catch (ClassNotFoundException e) {    e.printStackTrace();}System.out.println(class3);</code></pre>  }<br>  //上边的方法是空参构造方法，如果必须要传递参数，就使用Constructor获取该类的构造函数对象<br>  public static void getClassObject3_2 ()<br>  {<pre><code>String className = &quot;test.Student&quot;;Class class3 = null;try {    class3 = Class.forName(className);    Constructor cons = class3.getConstructor(String.class,int.class);// 类型.Class  代表该数据类型的Class对象    Object obj = cons.newInstance(&quot;王五&quot;,20);} catch (Exception e) {    e.printStackTrace();}System.out.println(class3);</code></pre>  }</li></ul><hr><h2 id="字段的获取"><a href="#字段的获取" class="headerlink" title="字段的获取"></a>字段的获取</h2><p>getField():该方法返回一个类或接口的一个公共成员字段<br>getFields():该方法返回一个类或接口的所有公共成员字段</p><p>getDeclaredField():返回包括公共和私有的字段，但不包括继承的字段<br>getDeclaredFields():返回所有。。。。。</p><p>//4.如何获取字段<br>    public static void getFidldDemo()<br>    {<br>        String classname = “test.Student”;<br>        Class class4 = null;<br>        Field f1 = null;<br>        Field f2 = null;<br>        try {<br>            class4 = Class.forName(classname);<br>            //f1 = class4.getField(“name”);//获取共有的字段<br>            f2 = class4.getDeclaredField(“age”);//获取私有的字段<br>            f2.setAccessible(true);//对私有字段的暴力访问<br>            Object obj = class4.newInstance();<br>            f2.set(obj,20);<br>            Object o = f2.get(obj);<br>            System.out.println(o);</p><pre><code>    }catch (Exception e){        e.printStackTrace();    }}</code></pre><hr><h2 id="函数的获取"><a href="#函数的获取" class="headerlink" title="函数的获取"></a>函数的获取</h2><p>getMethod():获取一个方法<br>getMethods():获取所有方法<br>invoke():执行方法</p><pre><code>//函数的使用//1.无参函数的使用        Method me1 = class5.getMethod(&quot;showName&quot;);        Constructor c = class5.getConstructor(String.class,int.class);        Object obj = c.newInstance(&quot;哈哈&quot;,12);        me1.invoke(obj,null);//这里的null是无参//2.有参函数的使用        Method me2 = class5.getMethod(&quot;show&quot;,String.class);//在此处加上参数的class类        Object o = class5.newInstance();        me2.invoke(o,&quot;嘿嘿&quot;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>注解</title>
      <link href="/2019/01/15/JavaSe/%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/01/15/JavaSe/%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>常见注解：@<br>@Override:表示该方法继承于父类。</p><p>@Deprecated:表示该方法已被遗弃。</p><p>@SuppressWarnings:用来抑制编译时的警告信息。<br><a id="more"></a></p><hr><h1 id="元注解：用来描述自定义注解的。"><a href="#元注解：用来描述自定义注解的。" class="headerlink" title="元注解：用来描述自定义注解的。"></a>元注解：用来描述自定义注解的。</h1><p>1<br>@Target:用于描述注解的使用范围<br>       |PACKAGE:修饰包<br>       |TYPE:修饰类，接口，枚举，Annotation类型<br>       |CONSTRUCTOR:用于描述构造器<br>       |FIELD:用于描述域<br>       |METHOD:用于描述方法<br>       |LOCAL VARIABLE:修饰局部变量<br>       |PARAMETER:修饰参数<br>    *举例：<br>        @Target(value=ElementType.METHOD)<br>        public @interface AnnotationDemo{<br>        }//此注解仅可用来描述方法</p><p>2<br>@Retention:表示需要在什么级别保存该注释信息，用于描述注解的生命周期<br>       |SOURCE:在源文件中有效（即源文件保留）<br>       |CLASS:在class文件中有效<br>       |RUNTIME:在运行时有效（为Runtime可以被反射机制读取）<br>    *举例：<br>        @Retention(RetentionPolicy.RUNTIME)<br>        public @interface AnnotationDemo{<br>            String Name() default “”;//default表示默认值,通常是空字符串<br>            int age() default 0;     //或者数字0或-1 (-1代表不存在)<br>        }//此注解可以被运行时读取</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java之UDP与TCP</title>
      <link href="/2019/01/15/JavaSe/java%E4%B9%8BUDP%E4%B8%8ETCP/"/>
      <url>/2019/01/15/JavaSe/java%E4%B9%8BUDP%E4%B8%8ETCP/</url>
      
        <content type="html"><![CDATA[<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>1.将数据及源和目的封装成数据包中，不需要建立连接<br>2.每个数据包的大小限制在64K以内<br>3.因无连接，所以不可靠协议<br>4.不需要建立连接，速度快</p><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>1.建立连接，形成传输数据的通道<br>2.在连接中进行大数据量传输<br>3.通过三次握手，是可靠协议<br>4.必须建立连接，效率稍低<br><a id="more"></a></p><h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>1.Socket就是为网络服务提供的一种机制<br>2.通信的两端都有Socket<br>3.网络通信其实就是Socket间的通信</p><h2 id="4-数据在两个Socket间通过IO传输"><a href="#4-数据在两个Socket间通过IO传输" class="headerlink" title="4.数据在两个Socket间通过IO传输"></a>4.数据在两个Socket间通过IO传输</h2><h2 id="UDP类"><a href="#UDP类" class="headerlink" title="UDP类"></a>UDP类</h2><p>DatagramSocket：此类表示用于发送和接收数据报数据包的套接字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 此代码演示UDP发送端</span><br><span class="line"> * */</span><br><span class="line">public class UDPsend &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)throws Exception</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        //定义一个UDP的Socket</span><br><span class="line">    DatagramSocket dS = new DatagramSocket() ;</span><br><span class="line">    String string = &quot;udpDemo&quot;;</span><br><span class="line">    byte[] buf =string.getBytes();</span><br><span class="line">    int length = buf.length;</span><br><span class="line">//获取本机IP</span><br><span class="line">    InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">//指定端口</span><br><span class="line">    int port= 7777; </span><br><span class="line">//DatagramPacket该类表示数据报包。 </span><br><span class="line">    DatagramPacket p = new DatagramPacket(buf, length, address, port);</span><br><span class="line">//发送</span><br><span class="line">    dS.send(p);</span><br><span class="line">//关闭</span><br><span class="line">    dS.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 此代码演示UDP接收端</span><br><span class="line"> * */</span><br><span class="line">public class UDPrece &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args)throws Exception</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    DatagramSocket ds = new DatagramSocket(7777);</span><br><span class="line">    byte[] buf = new byte[1024];</span><br><span class="line">    DatagramPacket dp = new DatagramPacket(buf,buf.length);</span><br><span class="line">    ds.receive(dp); </span><br><span class="line">    byte[] data = dp.getData();</span><br><span class="line">    int length =dp.getLength();</span><br><span class="line">    String receiveddata= new String(data, 0, length);</span><br><span class="line">    System.out.println(&quot;Udp&quot;+receiveddata);</span><br><span class="line">    ds.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="TCP类"><a href="#TCP类" class="headerlink" title="TCP类"></a>TCP类</h2><p>tcp分客户端和服务端<br>Socket:客户端对应的对象<br>ServerSocket:服务端对应的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/*客户端</span><br><span class="line">*在该对象建立时，就可以去连接指定主机。</span><br><span class="line">*因为tcp是面向连接的，所以在建立socket服务时，</span><br><span class="line">*就要有服务端的存在，并连接成功，形成通路后，在该通道进行数据的传输</span><br><span class="line">*/</span><br><span class="line">public static void main(String[] arg)</span><br><span class="line">&#123;</span><br><span class="line">//创建客户端的Socket服务，指定目的主机和端口</span><br><span class="line">Socket s = new Socket(&quot;192.168.1.254&quot;,10086);</span><br><span class="line">//为了发送数据，应该获取socket流中的输出流</span><br><span class="line">OutputStream out = s.getOutputStream();</span><br><span class="line">out.write(&quot;TCPDemo&quot;.getBytes());</span><br><span class="line">s.close();</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">*服务端</span><br><span class="line">*1.建立服务端的socket服务，ServerSocket，并监听一个端口</span><br><span class="line">*2.获取连接过来的客户端对象</span><br><span class="line">*    通过ServerSocket的 accept 方法。（阻塞式方法）</span><br><span class="line">*3.客户端如果发过来数据，那么服务端要使用对应的客户端对象，</span><br><span class="line">*  并获取到该对象的读取流来读取发过来的数据。并打印出来。</span><br><span class="line">*4.(可选)关闭服务</span><br><span class="line">*/</span><br><span class="line">public static void main(String[] arg)</span><br><span class="line">&#123;</span><br><span class="line">//建立服务端的socket服务并监听一个端口</span><br><span class="line">ServerSocket ss = new ServerSocket(10003);</span><br><span class="line">//通过accept方法获取连接过来的客户端对象</span><br><span class="line">Socket s = ss.accept();</span><br><span class="line"></span><br><span class="line">String ip = s.getInetAddress().getHostAddress();</span><br><span class="line">System.out.println(ip+&quot;:&quot;);</span><br><span class="line">//使用客户端对象的读取流来读取数据</span><br><span class="line">InputStream in = s.getInputStream();</span><br><span class="line"></span><br><span class="line">byte[] buf = new byte[1024];</span><br><span class="line">int len = in.read(buf);</span><br><span class="line">System.out.println(new String (buf,0,len));</span><br><span class="line"></span><br><span class="line">//关闭客户端</span><br><span class="line">s.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="并发TCP"><a href="#并发TCP" class="headerlink" title="并发TCP"></a>并发TCP</h2><p>为了解决多客户端访问服务器的问题<br>于是需要使用多线程技术<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class TcpServer</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] srgs) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">    ServerSocket ss = new ServerSocket(10000);</span><br><span class="line">while(ture)//使用while(ture)，每当新的客户端连接进来，就开启一个新线程</span><br><span class="line">&#123;</span><br><span class="line">   Socket s = ss.accept();</span><br><span class="line">   new Thread(new TcpThread(s)).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>*举例：并发TCP上传图片</p><pre><code>Class TcpThread implements Runnable{    private Socket s;    TcpThread(Socket s)    {       this.s = s;    }    public void run()    {        String ip = s.getInetAddress().getHostAddress();        try        {            int count = 1;            System.out.println(ip+&quot;...connecting&quot;);            InputStream in = s.getInputStream();            File file = new File(ip+&quot;(&quot;+(count)+&quot;)&quot;+&quot;.jpg&quot;);            while(file.exists())            {               file = new File(ip+&quot;(&quot;+(count++)+&quot;)&quot;+&quot;.jpg&quot;);            }            FileOutputStream fos = new FileOutputStream(&quot;file&quot;);            byte[] buf = new byte[1024];            int len = 0;            while((len=in.read(buf)) != -1)            {                fos.write(buf,0,len);            }            OutputStream out = s.getOutputStream();            out.write(&quot;上传成功&quot;.getBytes());            fos.close();            s.close();        }        catch (Exception e)        {            throw new RuntimeException(ip+&quot;上传失败&quot;);        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA之GUI入门</title>
      <link href="/2019/01/15/JavaSe/JAVA%E4%B9%8BGUI%E5%85%A5%E9%97%A8/"/>
      <url>/2019/01/15/JavaSe/JAVA%E4%B9%8BGUI%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="GUI：Graphical-User-Interface-图形用户接口）"><a href="#GUI：Graphical-User-Interface-图形用户接口）" class="headerlink" title="GUI：Graphical User Interface(图形用户接口）"></a>GUI：Graphical User Interface(图形用户接口）</h1><p>CLI：Command line User Interface(命令行用户接口）</p><p>JAVA：<br>   |Awt:需要调用本地系统方法实现功能，依赖平台，不同系统显示会有区别，重量级控件<br>   |Swing:在AWT基础上建立的，提供了更多的组建，完全由JAVA实现，轻量级控件。<br><a id="more"></a></p><h2 id="事件监听机制："><a href="#事件监听机制：" class="headerlink" title="事件监听机制："></a>事件监听机制：</h2><p><em>1.事件源</em><br><em>2.事件</em><br><em>3.监听器</em><br><em>4.事件处理</em></p><p>事件源：就是awt包或者swing包中的那些图形界面组件<br>事件：每一个事件源都有自己特有的对应事件和共性事件。<br>监听器：将可以触发某一个事件的动作（不止一个动作）都已经封装到了监听器中。</p><p>以上三者在JAVA中已经定义好了，直接获取其对象来用就可以了</p><h2 id="需要做的就是第四条"><a href="#需要做的就是第四条" class="headerlink" title="需要做的就是第四条"></a>需要做的就是第四条</h2><h2 id="Frame窗体"><a href="#Frame窗体" class="headerlink" title="Frame窗体"></a>Frame窗体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 此代码演示</span><br><span class="line"> * 创建图形化界面</span><br><span class="line"> * 1.创建frame窗体</span><br><span class="line"> * 2.对窗体进行设置</span><br><span class="line"> * 3.定义组件</span><br><span class="line"> * 4.用add方法将组件添加</span><br><span class="line"> * 5.通过setVisible将窗体显示 </span><br><span class="line">  * 实现关闭事件的类是我自定义的另一个代码&quot;Mywin.java&quot;中</span><br><span class="line"> * */</span><br><span class="line"></span><br><span class="line">public class FrameDemo &#123;</span><br><span class="line"></span><br><span class="line">private Frame fr;</span><br><span class="line">private Button bu;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public FrameDemo() &#123;</span><br><span class="line">init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void init()//初始化</span><br><span class="line">&#123;</span><br><span class="line">//新建frame窗体</span><br><span class="line">fr = new Frame();//默认边界式式布局</span><br><span class="line">//调整大小</span><br><span class="line">fr.setSize(500,400);</span><br><span class="line">//调整方位</span><br><span class="line">fr.setLocation(50,40);</span><br><span class="line">//更改布局方式为流式</span><br><span class="line">fr.setLayout(new FlowLayout());</span><br><span class="line">//定义按钮</span><br><span class="line">bu = new Button(&quot;按钮&quot;);</span><br><span class="line">//添加组件</span><br><span class="line">fr.add(bu);</span><br><span class="line">//选择是否可显示</span><br><span class="line">fr.setVisible(true);</span><br><span class="line">//加载事件</span><br><span class="line">Myevent();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void Myevent()</span><br><span class="line">&#123;</span><br><span class="line">//添加窗口监听器，定义关闭窗体事件</span><br><span class="line">fr.addWindowListener(new Mywin());</span><br><span class="line">bu.addActionListener(new ActionListener() &#123;//匿名内部类</span><br><span class="line"></span><br><span class="line">public void actionPerformed(ActionEvent e) &#123;</span><br><span class="line">System.out.println(&quot;按钮按了一下&quot;);</span><br><span class="line">System.exit(0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new FrameDemo();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">bu.addMouseListener(new MouseAdapter()</span><br><span class="line">&#123;</span><br><span class="line">private int count = 1;</span><br><span class="line">private int clickCount = 1;</span><br><span class="line">public void mouseEntered(MouseEvent e)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;鼠标进入该组件&quot;+count++);</span><br><span class="line">&#125;</span><br><span class="line">public void mouseClicked(MouseEvent e)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;点击动作&quot;+clickCount++);</span><br><span class="line">if(e.getClickCount()==2)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;双击动作&quot;+clickCount++);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bu.addActionListener(new ActionListener()</span><br><span class="line">&#123;</span><br><span class="line">public void actionPerformed(ActionEvent e)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;action ok&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//ΜνΌΣΌόΕΜΌΰΜύ</span><br><span class="line">bu.addKeyListener(new KeyAdapter()</span><br><span class="line">&#123;</span><br><span class="line">public void keyPressed(KeyEvent e)</span><br><span class="line">&#123;</span><br><span class="line">                System.out.println(KeyEvent.getKeyText(e.getKeyCode())+&quot; &quot;+e.getKeyCode());</span><br><span class="line">if (e.getKeyCode()==KeyEvent.VK_ENTER) </span><br><span class="line">&#123;</span><br><span class="line">System.exit(0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>properties</title>
      <link href="/2019/01/15/JavaSe/properties/"/>
      <url>/2019/01/15/JavaSe/properties/</url>
      
        <content type="html"><![CDATA[<h1 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h1><p>  是hashtable的子类<br>  *也就是说它具备了map集合的特点，并且存储的键值对都是字符串<br>   是集合中和IO技术相结合的集合容器。<br>特点：可以用于键值对形式的配置文件<br><a id="more"></a></p><hr><p>功能：<br>  setProperty(key,value);//添加新的键值对<br>  getProperty(key);//返回某个键所对应的值<br>  stringPropertyNames();//返回所有的key键<br>  load();将流中的数据加载进集合<br>  store(OutputStream out, String comments):将此 Properties 表中的属性列表（键和元素对）写入输出流。<br>  store(Writer writer, String comments):同上</p><hr><p>演示：<br>如何将流中的数据存储到集合中,并在集合中修改后也可以同时修改文件中的数据<br>  提示思路:|–1.用一个流和文件关联。<br>           |–2.读取一行数据，将该行数据用“=”进行切割。<br>           |–3.等号左边作为键，右边作为值。存入到Properties集合中即可。<br>  <strong>*</strong>load()自动封装好了以上功能<br>{<br>  Properties prop = new Properties();<br>  FileInputStream fis = new FileInputStream(“demo.txt”);<br>  prop.load(fis);<br>  prop.setProperty(“b”,”6”);<br>  FileOutputStream fos = new FileOutputStream(“demo.txt”);<br>  prop.store(fos,”idea”);<br>  prop.list(System.out);<br>  fos.close();<br>  fis.close();<br>}</p><hr><h2 id="演示练习"><a href="#演示练习" class="headerlink" title="演示练习"></a>演示练习</h2><p>/**</p><ul><li>此代码演示要求如下：</li><li>应用程序可免费使用5次，5次以后会提示“Sorry”并中止程序。</li><li></li><li>原理实现：</li><li>每次用户打开都会将count.ini文件中的time值加一（无文件则自动新创建）</li><li></li><li><em>/<br>import java.io.</em>;<br>import java.util.Properties;</li></ul><p>public class PropertiesTest {</p><pre><code>public static void main(String[] args) throws IOException {    Properties pr = new Properties();    File f = new File(&quot;C:\\Users\\IO流\\测试数据\\count.ini&quot;);    if(!f.exists())    {        f.createNewFile();    }    FileInputStream fis = new FileInputStream(f);    pr.load(fis);    int count = 0;    String value = pr.getProperty(&quot;time&quot;);    if(value != null)    {        count = Integer.parseInt(value);        if(count &gt;= 5)        {            System.out.println(&quot;Sorry&quot;);            return ;        }    }    System.out.println(&quot;程序启动成功&quot;);    count++;    pr.setProperty(&quot;time&quot;,count+&quot;&quot;);    FileOutputStream fos = new FileOutputStream(&quot;C:\\Users\\IO流\\测试数据\\count.ini&quot;);    pr.store(fos, &quot;Data update&quot;);    fis.close();    fos.close();}</code></pre><p>}</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流之字节流</title>
      <link href="/2019/01/10/JavaSe/io%E6%B5%81/IO%E6%B5%81%E4%B9%8B%E5%AD%97%E8%8A%82%E6%B5%81/"/>
      <url>/2019/01/10/JavaSe/io%E6%B5%81/IO%E6%B5%81%E4%B9%8B%E5%AD%97%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><p>注意：<br>字节流并没有刷新，因为字节流底层并没有缓冲区，<br>字符流需要缓存一个字符的字节再刷新。<br><a id="more"></a><br>    public static void writeFile() throws IOException<br>    {<br>        FileOutputStream fos = new FileOutputStream(“C:\Users\IO流\demo.txt”);<br>        fos.write(“abcd”.getBytes());//getBytes将字节变为字符<br>        fos.close();<br>    }</p><pre><code>public static void readFile() throws IOException{    FileInputStream fis = new FileInputStream(&quot;C:\\Users\\12.IO流\\demo.txt&quot;);    byte[] buf = new byte[fis.available()];//定义一个刚刚好的缓冲区，不用循环    fis.read(buf);    System.out.println(new String(buf));    fis.close();}</code></pre><hr><h2 id="read方法注意"><a href="#read方法注意" class="headerlink" title="read方法注意"></a>read方法注意</h2><p>注意：read()方法读取的是一个字节,为什么返回是int,而不是byte<br>字节输入流可以操作任意类型的文件,比如图片音频等,这些文件底层都是以二进制形式的存储的,如果每次读取都返回byte,有可能在读到中间的时候遇到111111111；那么这11111111是byte类型的-1,我们的程序是遇到-1就会停止不读了,后面的数据就读不到了,所以在读取的时候用int类型接收,如果11111111会在其前面补上；24个0凑足4个字节,那么byte类型的-1就变成int类型的255了这样可以保证整个数据读完,而结束标记的-1就是int类型</p><hr><h2 id="复制一个图片："><a href="#复制一个图片：" class="headerlink" title="复制一个图片："></a>复制一个图片：</h2><p>思路：<br>1.用字节读取流对象和图片关联。<br>2.用字节写入流对象创建一个图片文件，用于存储获取到的图片数据。<br>3.通过循环读写，完成数据的存储。<br>4.关闭资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 此代码是演示用字节流实现图片的复制</span><br><span class="line"> * */</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class CopyPicture &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">FileOutputStream fos = null;</span><br><span class="line">FileInputStream fis =null;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">fis = new FileInputStream(&quot;C:\\Users\\IO流\\测试数据\\1.png&quot;);</span><br><span class="line">fos = new FileOutputStream(&quot;C:\\Users\\IO流\\测试数据\\2.png&quot;);</span><br><span class="line"></span><br><span class="line">byte[] buf = new byte[1024];</span><br><span class="line">int len = 0;</span><br><span class="line">while((len = fis.read(buf)) != -1)</span><br><span class="line">&#123;</span><br><span class="line">fos.write(buf,0,len);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">throw new RuntimeException(&quot;打开失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">if(fos!=null) &#123;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">fos.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">throw new RuntimeException(&quot;写入关闭失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(fis!=null)</span><br><span class="line">&#123;</span><br><span class="line">try &#123;</span><br><span class="line">fis.close();</span><br><span class="line">&#125;catch (IOException e) &#123;</span><br><span class="line">throw new RuntimeException(&quot;读取关闭失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="演示mp3的复制，通过缓冲区："><a href="#演示mp3的复制，通过缓冲区：" class="headerlink" title="演示mp3的复制，通过缓冲区："></a>演示mp3的复制，通过缓冲区：</h2><p>BufferedOutputStream<br>BufferedInputStream<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 此代码演示使用字节流缓冲区复制mp3文件</span><br><span class="line"> * 为了方便，我没有写try代码块而是直接抛出异常</span><br><span class="line"> * 具体的异常处理方式请看该包内的另一个文档&quot;CopyPicture.java&quot;</span><br><span class="line"> * */</span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public interface CopyMp3 &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">long start = System.currentTimeMillis();</span><br><span class="line">Copymp3();</span><br><span class="line">long end = System.currentTimeMillis();</span><br><span class="line">System.out.println(end-start+&quot;毫秒&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public static void Copymp3() throws IOException</span><br><span class="line">&#123;</span><br><span class="line">FileInputStream fis = new FileInputStream(&quot;C:\\Users\\IO流\\测试数据\\1.mp3&quot;);</span><br><span class="line">BufferedInputStream bis = new BufferedInputStream(fis);</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;C:\\Users\\IO流\\测试数据\\2.mp3&quot;);</span><br><span class="line">BufferedOutputStream bos = new BufferedOutputStream(fos);</span><br><span class="line">int by = 0;</span><br><span class="line">while((by = bis.read()) != -1)</span><br><span class="line">&#123;</span><br><span class="line">bos.write(by);</span><br><span class="line">&#125;</span><br><span class="line">bos.close();</span><br><span class="line">bis.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> JAVASE之IO流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流之缓冲区</title>
      <link href="/2019/01/10/JavaSe/io%E6%B5%81/IO%E6%B5%81%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA/"/>
      <url>/2019/01/10/JavaSe/io%E6%B5%81/IO%E6%B5%81%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="IO流-BufferedInputStream和BufferOutputStream拷贝"><a href="#IO流-BufferedInputStream和BufferOutputStream拷贝" class="headerlink" title="IO流(BufferedInputStream和BufferOutputStream拷贝)"></a>IO流(BufferedInputStream和BufferOutputStream拷贝)</h2><a id="more"></a><ul><li>A:缓冲思想<br>　　<em> 字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多，　　</em> 这是加入了数组这样的缓冲区效果，java本身在设计的时候，<br>　　* 也考虑到了这样的设计思想，所以提供了字节缓冲区流</li><li>B.BufferedInputStream<br>　　<em> BufferedInputStream内置了一个缓冲区(数组)　　</em> 从BufferedInputStream中读取一个字节时<br>　　<em> BufferedInputStream会一次性从文件中读取8192个, 存在缓冲区中, 返回给程序一个　　</em> 程序再次读取时, 就不用找文件了, 直接从缓冲区中获取<br>　　* 直到缓冲区中所有的都被使用过, 才重新从文件中读取8192个</li><li>C.BufferedOutputStream<br>　　<em> BufferedOutputStream也内置了一个缓冲区(数组)　　</em> 程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中<br>　　* 直到缓冲区写满, BufferedOutputStream才会把缓冲区中的数据一次性写到文件里</li></ul><hr><h2 id="字符读取流缓冲区："><a href="#字符读取流缓冲区：" class="headerlink" title="字符读取流缓冲区："></a>字符读取流缓冲区：</h2><p>特有功能：readLine();//读取一行,返回值是字符串，读到结尾是null</p><p>举例:<br>{<br>   //创建一个读取流对象和文件相关联<br>   FileReader fr = new FileReader(“buf.txt”);</p><p>   //将字符读取流对象作为参数传递给缓冲对象的构造函数。<br>   BufferedReader bufr = new BufferedRead();</p><p>   //读取一行<br>   Sting line = null;<br>   while( (line = bufr.readLine() )!=null)<br>   {<br>       System.out.println(line);<br>   }</p><h2 id><a href="#" class="headerlink" title="}"></a>}</h2><h2 id="字符流的缓冲区："><a href="#字符流的缓冲区：" class="headerlink" title="字符流的缓冲区："></a>字符流的缓冲区：</h2><p>因为缓冲区技术是为流技术存在的，所以建立缓冲区之前必须先有流对象。然后把流对象作为参数传给缓冲对象的构造函数，注意，缓冲类是没有空参数构造函数的，他必须在流对象的前提下创建。原理就是对象中封装了数组。</p><ul><li>缓冲区要结合流才可以使用</li><li>在流的基础上对流的功能进行了增强</li></ul><p>对应类：<br>BufferedWriter<br>BufferedReader</p><p>** 特有功能：newLine()//增加一个行分隔符，JAVA中封装了各种系统的换行字符。</p><p>举例：<br>{<br>   //创建字符写入流对象<br>   FileWriter fw = new FileWriter(“buf.txt”);</p><p>   //将需要被提高效率的流对象作为参数传递给缓冲区的构造函数<br>     BufferedWriter bufw = new BufferedWriter(fw);</p><p>   //换行<br>     bufw.wirte(“abc”);<br>     bufw.newLine();</p><p>   //刷新<br>     bufw.flush();</p><p>   //其实关闭缓冲区，就是在关闭缓冲区中的流对象<br>     bufw.close();<br>}</p><hr><h2 id="缓冲区提高效率的原理"><a href="#缓冲区提高效率的原理" class="headerlink" title="缓冲区提高效率的原理"></a>缓冲区提高效率的原理</h2><p>调用I\O操作的时候，实际上还是一个一个的读或者写。<br>关键就在，<br>CPU只有一个，不论是几个核心。<br>CPU在系统调用时，会不会还要参与主要操作？参与多次就会花更多的时间。</p><p>系统调用时，若不用缓冲，CPU会酌情考虑使用中断。<br>此时CPU是主动地，每个周期中都要花去一部分去询问I\O设备是否读完数据，<br>这段时间CPU不能做任何其他的事情（至少负责执行这段模块的核不能）。<br>所以，调用一次读了一个字，通报一次，CPU腾出时间处理一次。</p><p>而设置缓冲，CPU通常会使用 DMA 方式去执行 I\O 操作。<br>CPU 将这个工作交给DMA控制器来做，自己腾出时间做其他的事，<br>当DMA完成工作时，DMA会主动告诉CPU“操作完成”。<br>这时，CPU接管后续工作。在此，CPU 是被动的。<br>DMA是专门做 I＼O 与内存数据交换的，不仅自身效率高，也节约了CPU时间，CPU在DMA开始和结束时做了一些设置罢了。<br>所以，调用一次，不必通报CPU，等缓冲区满了，DMA 会对C PU 说 “嘿，伙计！快过来看看，把他们都搬走吧”。</p><p> 综上，设置缓冲，就建立了数据块，使得DMA执行更方便，CPU也有空闲，而不是呆呆地候着I\O数据读来。从微观角度来说，设置缓冲效率要高很多。尽管，不能从这个程序上看出来。 几万字的读写\就能看到差距</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE之IO流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符流</title>
      <link href="/2019/01/10/JavaSe/io%E6%B5%81/%E5%AD%97%E7%AC%A6%E6%B5%81/"/>
      <url>/2019/01/10/JavaSe/io%E6%B5%81/%E5%AD%97%E7%AC%A6%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><h2 id="1-字符流是什么？"><a href="#1-字符流是什么？" class="headerlink" title="1.字符流是什么？"></a>1.字符流是什么？</h2><p>　　<em> 字符流是可以直接读写字符的IO流　　</em> 字符流读取字符, 就要先读取到字节数据, 然后转为字符. 如果要写出字符, 需要把字符转为字节再写出.　<br><a id="more"></a>　　　</p><h2 id="2-IO流-什么情况下使用字符流"><a href="#2-IO流-什么情况下使用字符流" class="headerlink" title="2.IO流(什么情况下使用字符流)"></a>2.IO流(什么情况下使用字符流)</h2><pre><code>* 字符流也可以拷贝文本文件, 但不推荐使用. 因为读取时会把字节转为字符, 写出时还要把字符转回字节.* 程序需要读取一段文本, 或者需要写出一段文本的时候可以使用字符流* 读取的时候是按照字符的大小读取的,不会出现半个中文* 写出的时候可以直接将字符串写出,不用转换为字节数组</code></pre><h2 id="3-IO流-字符流是否可以拷贝非纯文本的文件"><a href="#3-IO流-字符流是否可以拷贝非纯文本的文件" class="headerlink" title="3.IO流(字符流是否可以拷贝非纯文本的文件)"></a>3.IO流(字符流是否可以拷贝非纯文本的文件)</h2><pre><code>* 不可以拷贝非纯文本的文件* 因为在读的时候会将字节转换为字符,在转换过程中,可能找不到对应的字符,就会用?代替,写出的时候会将字符转换成字节写出去* 如果是?,直接写出,这样写出之后的文件就乱了,看不了了</code></pre><hr><h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer:"></a>Writer:</h2><p>举例：<br>  在硬盘上，创建一个文件并写入一些文字数据</p><p>{<br>    //创建一个FileWriter对象。该对象一被初始化就要明确被操作的文件。<br>    //而且该文件会被创建到指定文件。如果该目录下已经有同名文件，会覆盖旧文件。<br>    FileWriter fw = new FileWriter(“C:\Users\王旭\Desktop\JAVA笔记\12.IO流\\demo.txt”);</p><pre><code>//传递一个ture参数，代表不覆盖已有的文件，并在已有文件的末尾处进行续写FileWriter fw = new FileWriter(&quot;demo.txt&quot;,ture);//调用write方法，将字符串写入到流中。 fw.Write(&quot;nihao \r\n hhh&quot;);//换行//将数据刷新到目的地中，也就是第一步中指定的路径。fw.flush();//关闭流资源，但是关闭之前，会刷新一次内部缓冲中的数据。fw.close();</code></pre><p>}</p><hr><h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p>举例：read()方法<br>{<br>  //创建一个文件读取流对象，和指定名称的文件相关联。<br>  //要保证该文件已经存在，若不存在会发生FileNotFoundExcption异常。<br>  FileReader fr = new FileReader(“demo.txt”);</p><p>  //调用读取流对象的read方法，功能返回值是int，<br>  //一次读一个字符，而且会自动往下读,如果到了末尾就返回-1。<br>  int ch = 0;<br>  while( (ch=fr.read()) != -1 )<br>  {<br>    System.out.println((char)ch);<br>   }<br>}</p><p>其他方法：</p><ul><li>read(char[] buf)//通过字符数组进行读取，返回的是读到的字符个数，到结尾返回-1<br>  举例： 假设文件中存储的是”abcd”<pre><code>char[] buf = new char[3];int num1 = fr.read(buf);System.out.println(new String(buf));int num2 = fr.read(buf);System.out.println(new String(buf));</code></pre> 打印结果：abc<pre><code>      dbc原因：到d之后就不能再录入了，所以数组的第二个和第三个没有变。</code></pre></li><li>read（char[] buf, int num1,int num2);//从第num1个位置开始读，读 num2 个字符           </li></ul><hr><h2 id="IO异常的处理方式"><a href="#IO异常的处理方式" class="headerlink" title="IO异常的处理方式"></a>IO异常的处理方式</h2><p>标准例子：<br>{<br>   FileWriter fw = null;//一定要在try代码块之前先定义fw，<br>                        //否则finally中使用不了close(),会报异常。<br>   try<br>   {<br>     fw = new FileWriter(“K:\Demo.txt”);<br>     fw.write(“abc”);<br>     fw.close();<br>    }<br>   catch(IOException e)<br>   {<br>      System.out.println(e.toString());<br>    }<br>   finally<br>   {<br>      if(fw != null)//为了避免不必要的异常，先进行if判断是否指向成功<br>      {<br>         try<br>         {<br>           fw.close();//因为该句也会出现异常，所以也得用try代码块框起来。<br>         }<br>         catch(IOException e)<br>         {<br>           System.out.println(e.toString());<br>         }<br>      }<br>    }<br>}</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE之IO流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>装饰流</title>
      <link href="/2019/01/01/JavaSe/io%E6%B5%81/IO%E6%B5%81%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%B5%81/"/>
      <url>/2019/01/01/JavaSe/io%E6%B5%81/IO%E6%B5%81%E4%B9%8B%E8%A3%85%E9%A5%B0%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="装饰类"><a href="#装饰类" class="headerlink" title="装饰类"></a>装饰类</h1><a id="more"></a><p>装饰设计模式：<br>当想要对已有对象进行功能增强时，可以定义类，<br>将已有对象传入，基于已有的功能，并提供加强功能。<br>那么自定义的类称之为装饰类。</p><p>模式举例：装饰类通常通过构造方法接收被装饰的对像，并提供能强的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public void chi()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;吃&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">class SuperPerson</span><br><span class="line">&#123;</span><br><span class="line">    private Person p;</span><br><span class="line">    SuperPerson(Person p)</span><br><span class="line">    &#123;</span><br><span class="line">        this.p = p;</span><br><span class="line">     &#125;</span><br><span class="line">    public void superChi()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;吃吃吃&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">* 此代码演示的是装饰类LineNumberReader中的部分方法</span><br><span class="line">* 主要作用是为了在读取每行的时候可以加上行数</span><br><span class="line">public class LineNumberReaderDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">FileReader fr = null;</span><br><span class="line">LineNumberReader lnr = null;</span><br><span class="line">try &#123;</span><br><span class="line">    fr = new FileReader(&quot;C:\\Users\\王旭\\Desktop\\JAVA笔记\\12.IO流\\demo.txt&quot;);</span><br><span class="line">lnr = new LineNumberReader(fr);</span><br><span class="line">String line = null;</span><br><span class="line">lnr.setLineNumber(23);//修改行数的初始基准数值</span><br><span class="line">while((line = lnr.readLine())!=null)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(lnr.getLineNumber()+&quot;:&quot;+line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">catch (IOException e)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(&quot;IO异常&quot;+e.toString());</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">if(fr != null)</span><br><span class="line">&#123;</span><br><span class="line">try &#123;</span><br><span class="line">lnr.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVASE之IO流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IO流</title>
      <link href="/2019/01/01/JavaSe/io%E6%B5%81/IO%E6%B5%81/"/>
      <url>/2019/01/01/JavaSe/io%E6%B5%81/IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><a id="more"></a><ul><li>1.流的分类：</li><li>按照数据流向的不同：输入流  输出流</li><li>按照处理数据的单位的不同：字节流  字符流（处理的文本文件）</li><li>按照角色的不同：节点流（直接作用于文件的）  处理流</li><li></li><li>2.IO的体系</li><li>抽象基类          节点流（文件流）        缓冲流（处理流的一种）</li><li>InputStream(读）  FileInputStream         BufferedInputStream</li><li>OutputStream      FileOutputStream        BufferedOutputStream</li><li>Reader            FileReader              BufferedReader</li><li>Writer            FileWriter              BufferedWriter</li></ul><p>注:由这四个类派生出来的子类名称都是以其父类名作为子类名的后缀</p><h2 id="流操作的规律"><a href="#流操作的规律" class="headerlink" title="流操作的规律"></a>流操作的规律</h2><p>1.明确源和目的。<br>   源：输入流 InputStream(读)  Reader<br>   目的：输出流 OutputStream  Writer</p><p>2.明确操作的数据是否是纯文本。<br>   是：字符流 Reader  Writer<br>   不是：字节流 InputStream  OutputStream</p><p>3.明确具体对象（通过设备区分）<br>   源设备：内存，硬盘，键盘<br>   目的：内存，硬盘，控制台</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE之IO流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2018/12/14/JavaSe/%E6%B3%9B%E5%9E%8B/"/>
      <url>/2018/12/14/JavaSe/%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><a id="more"></a><p>泛型：在JDK1.4之前，容器什么类型的对象都可以存储，但是在取出时<br>      需要用到对象的特有内容时，需要向下转型，<br>      但是对象的类型不一致，导致了向下转型发生了ClassCastException<br>      为了避免这个问题，只能主观上控制，往集合中存储的对象类型保持一致</p><pre><code>JDK1.5以后，在定义集合时，就直接明确了集合中存储元素的具体类型，这样，编译器在编译时，就可以对集合中存储的对象类型进行检查，一旦发现类型不匹配，就编译失败，这个技术就是泛型。</code></pre><p>  |<br>  |好处：1.将运行时期的问题转移到了编译时期。<br>  |      2.避免了向下转型的麻烦。<br>  |*总结：泛型就是应用在编译时期的一项安全机制。</p><hr><p>  泛型的擦除：编译器通过泛型对元素类型进行检查，只要检查通过，<br>              就会生成class文件，但在class文件中，泛型的标识被去掉了</p><hr><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>背景前提：<br>        当创建一个工具类的时候，想要对对象进行操作，但是对象类型不明确，<br>        为了能使该类可以操作所有对象，可以使用Object类型来完成。<br>        But弊端：<br>        当出现转型的时候，如果类型输入的不一样，该错误无法在编译时期<br>        被发现，所以就会出现类型转换异常，为了解决这种问题，所以可以<br>        对外提供参数，由使用者通过传递参数的形式完成类型的确定。</p><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Tool&lt;lei&gt;</span><br><span class="line">&#123;</span><br><span class="line">   private lei obj;</span><br><span class="line">   public lei getObj()   </span><br><span class="line">   &#123;</span><br><span class="line">     return obj;</span><br><span class="line">   &#125;</span><br><span class="line">   public void setObj(lei obj)</span><br><span class="line">   &#123;</span><br><span class="line">     this.obj = obj;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main&#123;</span><br><span class="line">  Tool&lt;student&gt; T = new Tool&lt;student&gt;();</span><br><span class="line">  T.setObj(new Student());</span><br><span class="line">  Student stu = T.getObj();</span><br><span class="line">  Syso(stu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>优点：在使用时就明确了要输入什么类型，这样子如果之后输入错误就会被编译器报错，<br>      并且这样使用不需要向下转型！<br><em>注意</em>：静态方法无法访问类上定义的泛型的。<br>       如果静态方法需要定义泛型，泛型只能定义在方法上。</p><hr><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>背景前提：<br>       class Demo<w><br>       {<br>             public void show(W w)<br>             {<br>                 System.out.println(“show:”+w);<br>              }<br>              public void print(W w)<br>              {<br>                 System.out.println(“print:”+w);<br>              }<br>        }</w></p><pre><code>当我在使用该类时    Demo&lt;String&gt; d = new Demo&lt;String&gt;();    d.show(&quot;a&quot;);    d.print(6);以上就会被报错，因为我已经声明了W类是String,如果我想要打印出6，我就必须新建一个W是整型类的Demo类，为了解决这个问题，我们可以使用泛型方法。    public &lt;Q&gt; void print(Q w)    {        System.out.println(&quot;print:&quot;+w);     } 在方法类型之前写一个泛型，这样子就可以解决以上问题。</code></pre><hr><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Inter&lt;T&gt;//</span><br><span class="line">&#123;</span><br><span class="line">     public void show(T t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class InterImpl&lt;w&gt; implements Inter&lt;w&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public void show(w t)</span><br><span class="line">    &#123;</span><br><span class="line">       syso</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="泛型的限定"><a href="#泛型的限定" class="headerlink" title="泛型的限定"></a>泛型的限定</h2><p> &lt;? extends E&gt; -上限：接收E类型或者E的子类型<br> &lt;? super E&gt;   -下限：接收E类型或者E的父类型</p><p>上限：一般往容器中存储元素时，如果集合定义了E类型，并且需要可以接收E类型的子类型<br>      这时就需要将泛型从<e> 改为 &lt;? extends E&gt;</e></p><p>下限：一般从容器中取出元素时，可以用E类型接收，也可以用E的父类型接收。</p><pre><code>所以可以用&lt;E&gt;,也可以用&lt;? super E&gt;</code></pre><hr><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符 ?"></a>通配符 ?</h2><p>//在不明确具体类型的情况下，可以使用通配符表示</p><p>例如：我想要实现一个输出函数，专门打印出集合<br>    List<student> list = new ArrayList<student>();<br>    Set<string> set = new HashSet<string>();<br>    printcoll(list);<br>    printcoll(set);<br>    private static void printcoll(Collection&lt;?&gt; coll)<br>    {<br>       for(Iterator&lt;?&gt; it = coll.iterator(); it,hasNext();)<br>       {<br>           Object obj = it.next();<br>           System.out.println(obj);<br>          //迭代器输出功能<br>       }<br>    }           </string></string></student></student></p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Map</title>
      <link href="/2018/12/14/JavaSe/%E9%9B%86%E5%90%88/Map/"/>
      <url>/2018/12/14/JavaSe/%E9%9B%86%E5%90%88/Map/</url>
      
        <content type="html"><![CDATA[<h1 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h1><p>Map：<br>  Hashtable:哈希表结构，同步的，不允许null键，null值<br>  HashMap:哈希表结构，不同步，允许null键，null键<br>  TreeMap:二叉树结构，不同步，可以对map集合中的键进行排序</p><a id="more"></a><hr><p>1.添加<br>      v put（key,value);//返回key所映射的上一个value，如果没有就返回null<br>2.删除<br>      v remove(key);//返回删除的value<br>3.获取<br>      v get(key);//返回value<br>4.返回</p><p> <strong>**</strong>Set keyset();//取出所有键并存储到set集合中<br>      使用例子(遍历集合）<br>                Set<string> keySet = map.keySet();<br>                for(Iterator<string> IT = keySet.iterator();it.hasNext();)<br>                {<br>                    String key = it.next();<br>                    String value = map.get(key);<br>                    System.out.println(key+”:”+value);<br>                 }<br>                <strong>**</strong>Map集合没有迭代器<strong>**</strong>  </string></string></p><p> <strong>**</strong>Set Entry();//取出所有键映射关系<br>      *entry就是map接口中的一个内部接口，因为只有键值对以后，才有映射关系<br>      使用举例：<br>     Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();<br>     for(Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it = netrySet.iterator();it.hasNext();)<br>     {<br>       Map.Entry(String,String&gt; me = it.next();<br>       String key = me.getKey();<br>       Stirng value = me.getValue();<br>       System.out.println(key+value);<br>     }<br> <strong>**</strong>values();//返回值<br>       Collection<string> values = map.values();</string></p><hr><h3 id="map集合被使用是因为具备映射关系"><a href="#map集合被使用是因为具备映射关系" class="headerlink" title="map集合被使用是因为具备映射关系"></a>map集合被使用是因为具备映射关系</h3><h3 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h3><p>思想关键：<strong>value值可以是各种类型</strong></p><p>举例：一个学校有多个教室，一个教室有多个学生<br>      学校-教室-学生</p><p>源码如下</p><p>public class MapDemo {</p><pre><code>public static void main(String[] args) {    HashMap&lt;String,HashMap&lt;String, String&gt;&gt; school = new HashMap&lt;String,HashMap&lt;String, String&gt;&gt;();//学校    HashMap&lt;String, String&gt; A = new HashMap&lt;String, String&gt;();//A班    HashMap&lt;String, String&gt; B = new HashMap&lt;String, String&gt;();//B班    //开始添加教室    school.put(&quot;A&quot;, A);    school.put(&quot;B&quot;, B);    //开始添加学生    A.put(&quot;1&quot;, &quot;zhang&quot;);    A.put(&quot;2&quot;, &quot;wang&quot;);    B.put(&quot;1&quot;, &quot;li&quot;);    B.put(&quot;2&quot;, &quot;zhao&quot;);    //开始输出学生信息    Iterator&lt;String&gt; it = school.keySet().iterator();    while(it.hasNext())    {        String room = it.next();        HashMap&lt;String, String&gt; roomName = school.get(room); //获得room所对应的HashMap对象        System.out.println(room+&quot;班&quot;);        getStudentInfo(roomName);    }}public static void getStudentInfo(HashMap&lt;String, String&gt; room) //获取学生信息{    Set&lt;String&gt; S = room.keySet();    for(Iterator&lt;String&gt; it = S.iterator();it.hasNext();)    {        String id = it.next();        String name = room.get(id);        System.out.println(&quot;id=&quot;+id+&quot; &quot;+&quot;name=&quot;+name);    }}</code></pre><p>} </p>]]></content>
      
      
      <categories>
          
          <category> JAVASE之集合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组和集合的转化</title>
      <link href="/2018/12/14/JavaSe/%E9%9B%86%E5%90%88/%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E8%BD%AC%E5%8C%96/"/>
      <url>/2018/12/14/JavaSe/%E9%9B%86%E5%90%88/%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E8%BD%AC%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="数组和集合的转化"><a href="#数组和集合的转化" class="headerlink" title="数组和集合的转化"></a>数组和集合的转化</h1><a id="more"></a><h2 id="把数组变成list集合有什么好处？"><a href="#把数组变成list集合有什么好处？" class="headerlink" title="把数组变成list集合有什么好处？"></a>把数组变成list集合有什么好处？</h2><pre><code>可以使用集合的思想和方法来操作数组中的元素</code></pre><p>举例1：将字符串数组转换成集合<br>String[] arr = {“a”,”b”,”c”};<br>List<string> list = Arrays.asList(arr);<br>//list.add(“QQ”);//禁止！！！！</string></p><p>*注意：将数组变成集合，不可以使用集合的增删方法！<br>      因为：数组的长度是固定的!!!</p><p>举例2：将整型数组转换成集合<br>int[] nums = {1,2,3};<br>List&lt;int[]&gt; li = Arrays.asList(nums);<br>syso(li);</p><p>*注意：这里的泛型必须是int[]，而不是integer，因为<br>       如果数组中的元素都是对象，那么变成集合时，数组中的元素就直接转成集合中的元素<br>       如果数组中的元素都是基本数据类型，那么会将该数组作为集合中的一个元素存在。</p><h2 id="集合变数组"><a href="#集合变数组" class="headerlink" title="集合变数组"></a>集合变数组</h2><p> Collection接口中的toArray方法。</p><p>举例1：<br>ArrayList<string> a = new ArrayList<string>();<br>a.add(“qq”);<br>a.add(“ww”);<br>a.add(“ee”);<br>String[] arr = a.toArray(new String[a.size()]);</string></string></p><p>*1.指定类型的数组应该定义为多长呢？<br> 当指定类型的数组长度小于了集合的size,那么该方法内部会创建一个新的数组，长度为size。<br> 当指定类型的数组长度大于了集合的size，就不会创建了，而是使用传递进来的数组。<br>所以：<br> 应该使用size表示长度最合适！</p><p>*2.为什么要将集合变数组？<br> 为了限定对元素的操作。<br> 比如 不希望该集合中的元素被增加删除，因为数组长度固定。       </p>]]></content>
      
      
      <categories>
          
          <category> JAVASE之集合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迭代器</title>
      <link href="/2018/12/14/JavaSe/%E9%9B%86%E5%90%88/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/2018/12/14/JavaSe/%E9%9B%86%E5%90%88/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器（Iterator）<br>           迭代：取出元素的一种方式<br>         （有没有？ 有/没有）<br>           迭代器不需要new。直接通过iterator()获取<br><a id="more"></a><br>**<br>　　迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。</p><p>　　Java中的Iterator功能比较简单，并且只能单向移动：</p><p>　　(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。</p><p>　　(2) 使用next()获得序列中的下一个元素。</p><p>　　(3) 使用hasNext()检查序列中是否还有元素。</p><p>　　(4) 使用remove()将迭代器新返回的元素删除。</p><hr><p>  开发时的常用写法：<br>           for(Iterator it = coll.iterator; it.hasNext();)<br>           {<br>               System.out.println(it.next());<br>           }<br>   为什么不使用while?<br>          while(it.hasNext)<br>           {<br>              System.out.println(it.next());<br>           }<br>           使用for循环的话，新建的it在使用以后就会自动释放</p><hr><h2 id="Enumneration-枚举"><a href="#Enumneration-枚举" class="headerlink" title="Enumneration:枚举"></a>Enumneration:枚举</h2><pre><code>功能和迭代器相同，已被取代</code></pre><p> *具备枚举取出方式的容器只有：Vector<br>  Vectot v = new Vector();<br>  v.add(“a”);<br>  v.add(“b”);<br>  v.add(“c”);</p><hr><p>  **获取枚举（已被抛弃）<br>  for(Enumeration en =v.elements();en.hasMoreElements();<br>  {<br>      syso;<br>  }</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE之集合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>增强for</title>
      <link href="/2018/12/14/JavaSe/%E9%9B%86%E5%90%88/%E5%A2%9E%E5%BC%BAfor/"/>
      <url>/2018/12/14/JavaSe/%E9%9B%86%E5%90%88/%E5%A2%9E%E5%BC%BAfor/</url>
      
        <content type="html"><![CDATA[<h1 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h1><a id="more"></a><p> 例：<br>  Collection coll = new ArrayList();<br>  coll.add(“abc1”);<br>  coll.add(“abc2”);<br>  coll.add(“abc3”);</p><p><strong>正常for循环</strong><br>  for(Iterator it = coll.iterator();it.hasNext();)<br>  {<br>      Object obj = it.next();<br>      System,out.println(obj);<br>  }</p><p><strong>增强for语句写法</strong><br>  for(Object obj : coll)<br>  {<br>     System,out.println(obj);<br>   }</p><p><strong>数组同理（不使用角标的情况才会使用）</strong><br>        int[] arr = {1,2,3,4};<br>        for(int x : arr)<br>        {   syso<br>           }</p><hr><p>  格式： for(元素类型变量 ：Collection容器or数组）<br>         {<br>            }<br>  区别：增强for必须有被遍历的目标，该目标只能是Collection或数组<br>  缺陷：只可以提取，不可以修改</p><hr><p>如果是Map集合怎么办？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,String&gt; hm = new HashMap&lt;Integer,String&gt;();</span><br><span class="line">hm.put(1,&quot;a&quot;);</span><br><span class="line">hm.put(2,&quot;b&quot;);</span><br><span class="line">hm.put(3,&quot;c&quot;);</span><br><span class="line">Set&lt;Integer&gt; keySet = hm.keySet();</span><br><span class="line">for(Integer i = keySet)</span><br><span class="line">&#123;</span><br><span class="line">    syso(i+hm.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(Map.Entry&lt;Integer,String&gt; me : hm.entrySet())</span><br><span class="line">&#123;</span><br><span class="line">    syso(me.getKey()+me.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
      
      
      <categories>
          
          <category> JAVASE之集合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Set</title>
      <link href="/2018/12/14/JavaSe/%E9%9B%86%E5%90%88/Set/"/>
      <url>/2018/12/14/JavaSe/%E9%9B%86%E5%90%88/Set/</url>
      
        <content type="html"><![CDATA[<h1 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h1><p>Set集合：不保证存储顺序，不能重复，和Collection的方法相同<br>   |      取出元素的方法只有一个：迭代器<br>   |-HashSet:哈希表结构（不同步的）<br>   |-TreeSet:二叉树结构（不同步的）可以对元素进行排序<br><a id="more"></a></p><h2 id="HashSet："><a href="#HashSet：" class="headerlink" title="HashSet："></a>HashSet：</h2><p>   哈希表在判断元素是否相同，依据hashCode方法。如果哈希冲突，就在判断元素的equals方法。<br>   练习：Set set = new HashSet();<br>         set.add(new Student(“wang”,18);<br>         set.add(new Strdent(“wang”,18);<br>   结果：都存进去了。why？<br>         原因是每一次存储学生对象，都先调用hashCode方法获取哈希值。<br>         但是调用的是Object类中的hashCode，所以new不同的对象，哈希值就不同。<br>         所以解决的方法就是：覆盖hashCode方法和equals方法。<br>       例：public int hashCode()<br>          {<br>              return <em>**;<br>           }        </em>覆盖hashCode方法是为了根据元素自身特点确定哈希值。<br>        *覆盖equals方法，是为了解决哈希值的冲突。</p><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet:"></a>TreeSet:</h2><p>比较方法的返回值是0就不保存（唯一性）<br>        根据比较来构建一个二叉树保存数据，最后进行二叉树的遍历输出。(顺序)</p><pre><code>public int compateTo(Object o){    Student stu = (Student)o;    int temp = this.age - stu.age;    return temp == 0 ? this.name.compareTo(stu.name) :temp; }如果元素具备的功能不是所需要的，也就是说不想按照自然排序的方法，而是按照自定义的排序方式，对元素进行排序。而且，存储到TreeSet中的元素万一没有比较功能，该如果排序呢？这是，就只能使用第二种比较方式                          --让集合具备比较功能</code></pre><p>。<br>         *实现Comparator接口，覆盖compare方法，将Comparator接口的对象，<br>          作为参数传递给TreeSet集合的构造函数。</p><pre><code>比较器更为灵活，自然排序通常作为元素的默认排序。</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVASE之集合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>List</title>
      <link href="/2018/12/14/JavaSe/%E9%9B%86%E5%90%88/List/"/>
      <url>/2018/12/14/JavaSe/%E9%9B%86%E5%90%88/List/</url>
      
        <content type="html"><![CDATA[<h1 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h1><h2 id="Iterator："><a href="#Iterator：" class="headerlink" title="Iterator："></a>Iterator：</h2><pre><code>是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</code></pre><a id="more"></a><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><pre><code>继承了Collection，是有序的列表。实现类有ArrayList、LinkedList、Vector、Stack等</code></pre><p>1.ArrayList是基于数组实现的，是一个数组队列。可以动态的增加容量！<br>2.LinkedList是基于链表实现的，是一个双向循环列表。可以被当做堆栈使用！<br>3.Vector是基于数组实现的，是一个矢量队列，是线程安全的！<br>4.Stack是基于数组实现的，是栈，它继承与Vector，特性是FILO（先进后出）！</p><p><strong>使用场景</strong></p><p>在实际的应用中如果使用到队列，栈，链表，首先可以想到使用List。</p><ol><li>当集合中对插入元素数据的速度要求不高，但是要求快速访问元素数据，则使用ArrayList！ </li></ol><p>2.当集合中对访问元素数据速度不做要求不高，但是对插入和删除元素数据速度要求高的情况，则使用LinkedList！ </p><p>3.当集合中有多线程对集合元素进行操作时候，则使用Vector！但是现在BVector现在一般不再使用，如需在多线程下使用，        可以用CopyOnWriteArrayList，在java.util.concurrent包下。 </p><ol start="4"><li>当集合中有需求是希望后保存的数据先读取出来，则使用Stack！</li></ol><hr><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>练习：往ArrayList中存储自定义对象。person(name,age)<br>思路：1.描述person<br>      2.定义容器对象。<br>      3.将多个person对象，存储到集合中。<br>      4.取出person对象</p><pre><code>//首先创建ArrayList集合对象  List list = new ArrayList();//然后添加person类型的对像  person p1 = new person(&quot;lisi&quot;,22);  person p2 = new person(&quot;wangmazi&quot;,23);  list.add(p1);  list.add(p2);  list.add(new person(&quot;lisi3&quot;,22));//取出元素  for(Iterator it = list.iterator();it.hasNext();        //*** it.next()；取出的元素都是Object类型的  {      person p = (person)it.next;//需要用到具体对象内容，所以向下转型      System.out.println(it.next()；    }</code></pre><hr><p>例题:删除数组中的重复元素<br> A  B  A  B  A  B  A<br> 1  2  3  4  5  6  7<br>方法一：通过两层for循环进行判断并用remove功能删除<br>        注意：remove会导致数组size减少，也就是说当删除下标3的A时，数组长度编程6，同时B变为3，<br>              此时如果再按照for循环增加计数下标，就会不能遍历到新的下标3，所以要在使用remove<br>              以后将下标集体减少1.</p><p>方法二：构建一个新数组，然后进行判断，没有重复元素就将原数组的元素赋值过去。</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE之集合 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2018/11/24/JavaSe/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/11/24/JavaSe/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><a id="more"></a><p>正则表达式的规则：<br>A：字符<br>      x  字符x<br>      \ 反斜线字符<br>      \n 换行<br>      \r 回车</p><p>B：字符类<br>     [abc]    a或b或c<br>     [^abc]   除了a,b,c以外<br>     [a-zA-Z] 所有字母<br>     [0-9]    所有数字</p><p>C：预定义字符类<br>     .  任何字符（需要用到.就要\.）<br>     \d 等同于[0-9]<br>     \D 同等与[^0-9]<br>     \w 单词字符= [a-zA-Z_0-9]</p><p>D:边界匹配器<br>     ^  行的开头<br>     $  行的结尾<br>     \b 单词边界(不是单词字符的地方)<br>            举例：hello world中的空格就是单词边界</p><p>E：Greedy 数量词<br>     x? x,</p><pre><code>不写了，自己查去</code></pre><hr><h2 id="JAVA方法"><a href="#JAVA方法" class="headerlink" title="JAVA方法"></a>JAVA方法</h2><p>public boolean matches(String regex)<br>告知此字符串是否匹配给定的正则表达式</p><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><pre><code>Scanner sc = new Scanner(System.in);String email = sc.nextLine();String regex = &quot;[a-zA-Z_0-9]+![a-zA-Z_0-9]{2,6}(\\.[a-zA-Z_0-9]{2,3})+&quot;;boolean flag = email.matcher(refex);System,out.println(&quot;flag:&quot;+flag);</code></pre><h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>public string[] split(string regex)//<br>                 根据匹配给定的正则表达式来拆分此字符串<br>                *此方法返回的数组包含此字符串的每个子字符串，<br>    使用举例：<br>             String s1 = “aa.bb.cc”;<br>             String[] s1Array = s1.split(“\.”);</p><pre><code>String s1 = &quot;aa   bb       cc&quot;;String[] s1Array = s1.split(&quot; +&quot;);String s1 = &quot;C:\\Users\\王旭\\Desktop\\JAVA笔记\\12.正则表达式&quot;;String[] s1Array = s1.split(&quot;\\\\&quot;);</code></pre><p><strong><strong><strong>*</strong></strong></strong>注意*：硬盘上的地址必须用\而不是一个\,所以此处用\\切割</p><p><em>注意</em>：<br>   1.”.”和“|”都是转义字符，必须得加”\“;　<br>     String.split(“\.”),这样才能正确的分隔开，不能用String.split(“.”);<br>     String.split(“\|”),这样才能正确的分隔开，不能用String.split(“|”);<br>   2.如果在一个字符串中有多个分隔符，可以用“|”作为连字符</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>如果将一个字符串元素排序呢？<br>1.把字符串进行分割，得到一个字符串数组。<br>2.把字符串数组变换成int数组。<br>3.排序<br>4.将int数组组装成一个字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;6 4 8 1 9&quot;;</span><br><span class="line">String[] s1 = s.split(&quot; &quot;);</span><br><span class="line">int[] arr = new int[strArray.length];</span><br><span class="line">for(int x=0;x&lt;arr.length; x++)</span><br><span class="line">&#123;</span><br><span class="line">    arr[x] = Integer.parseInt(strArray[x]);</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">for(int x = 0; x&lt;arr.length; x++)</span><br><span class="line">&#123;</span><br><span class="line">    sb.append(arr[x]).append(&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">String result = sb.toString().trim();</span><br></pre></td></tr></table></figure><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>替换功能：<br>  String类的replaceAll(String regex,string replacement)<br>  使用给定的replacement替换此字符串所有匹配给定的正则表达式的子字符串<br>    举例：屏蔽掉字符串中的敏感字符<br>     String s = “+VX123456789”;<br>     String regex = “\d”;<br>     String ss = “<em>“;<br>     String result = s.replaceAll(regex,ss);<br>     syso(result);<br>     结果:+vx<strong><em>**</em></strong></em></p><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>获取:将字符串中的符合规则的子串取出</p><p>操作步骤：<br>1.将正则表达式封装成对象。<br>2.让正则对象和要操作的字符串相关联。<br>3.关联后，获取正则匹配引擎。<br>4.通过引擎对符合规则的子串进行操作，比如取出</p><p>Pattern和Matcher类</p><p>举例：<br>    String str = “wow ming tian yao xia yu”;</p><pre><code>String regex = &quot;\\b[a-z]{3}\\b&quot;;Pattern p = Pattern.compile(regex);//将规则封装成对象Matcher m = p.matcher(str);//让正则对象和要作用的字符串相关联，获取匹配器对象System.out.println(&quot;matches:&quot;+m.matcher());//判断是否符合规则while(m.find())//find将规则作用到字符串上，并进行符合规则的子串查找。{   syso(m.group());//group用于获取匹配后的结果。 }</code></pre><p><strong>***</strong>注意，此处打印出的只有yao xia两个，而没有wow。<br>       why?<br>       因为之前调用了一次matcher()方法进行了一次符合判定，<br>       matcher()因为接收到空格而判断为false。<br>       但是匹配器的索引位置却已经过了wow的位置。<br>       所以这是容易漏掉第一个的易错点</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>String缓冲区</title>
      <link href="/2018/11/14/JavaSe/String%E7%BC%93%E5%86%B2%E5%8C%BA/"/>
      <url>/2018/11/14/JavaSe/String%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="String缓冲区"><a href="#String缓冲区" class="headerlink" title="String缓冲区"></a>String缓冲区</h1><a id="more"></a><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p>//1.创建一个缓冲区对象<br>    StringBuffer sb = new StringBuffer();<br>//2.追加一个字符串<br>    sb.append(“abc”);<br>//3.插入一个boolean值<br>    sb.insert(1,ture);<br>//4.删除字符<br>    sb.delete(1,4);删除索引1-4的<br>//5.修改字符<br>    sb.replace(1,5,”false”);</p><p>*在内存中的过程。<br>                 1，创建一个字符串缓冲区容器。<br>                 2，将要组成字符串的元素先存储起来。<br>                 3，最后将缓存区填充数据编程字符串。</p><p><em>字符串缓存区中维护了一个可变长度的数组</em><br><em>解释</em>：其实就是超出内部数组长度后，新建数组的长度是原数组的1.5倍或1.75等以上。<br>       并将原数组的数据复制到新数组中，并将新的元素添加到新数组中。</p><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>用法和StringBuffer相同，但是只适合单线程，是线程不同步的。<br>一般建议首选StringBuilder，因为速度快</p><p><strong>不安全性举例</strong>：<br>        当一个容器正在添加的时候同时又被另一个线程操作删除，就会出现了问题。<br>        所以给各种方法加了锁，但是锁就会影响速度</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>String详解</title>
      <link href="/2018/11/14/JavaSe/String%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/11/14/JavaSe/String%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="String与常量池"><a href="#String与常量池" class="headerlink" title="String与常量池"></a>String与常量池</h1><p>常量池：<br>Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。<br><a id="more"></a><br>     所谓静态常量池，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。这种常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p><p><em>类和接口的全限定名</em><br><em>字段名称和描述符</em><br><em>方法名称和描述符</em><br>     而运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。</p><p>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。<br>String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池。</p><h2 id="常量池的好处"><a href="#常量池的好处" class="headerlink" title="常量池的好处"></a>常量池的好处</h2><p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。<br>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。<br><strong>（1）节省内存空间</strong>：常量池中所有相同的字符串常量被合并，只占用一个空间。<br><strong>（2）节省运行时间</strong>：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。<br>        例：String str = “abc”;<br>            str = “hello”;<br>            此时并不是”hello”覆盖了”abc”！</p><pre><code>而是str由本来指向&quot;abc&quot;转为了指向&quot;hello&quot;</code></pre><hr><h2 id="String-的例题"><a href="#String-的例题" class="headerlink" title="String 的例题"></a>String 的例题</h2><p><strong>从代码开始入手String</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;Hello&quot;;</span><br><span class="line">String s2 = &quot;Hello&quot;;</span><br><span class="line">String s3 = &quot;Hel&quot; + &quot;lo&quot;;</span><br><span class="line">String s4 = &quot;Hel&quot; + new String(&quot;lo&quot;);</span><br><span class="line">String s5 = new String(&quot;Hello&quot;);</span><br><span class="line">String s6 = s5.intern();</span><br><span class="line">String s7 = &quot;H&quot;;</span><br><span class="line">String s8 = &quot;ello&quot;;</span><br><span class="line">String s9 = s7 + s8;</span><br><span class="line">          </span><br><span class="line">System.out.println(s1 == s2);  // true</span><br><span class="line">System.out.println(s1 == s3);  // true</span><br><span class="line">System.out.println(s1 == s4);  // false</span><br><span class="line">System.out.println(s1 == s9);  // false</span><br><span class="line">System.out.println(s4 == s5);  // false</span><br><span class="line">System.out.println(s1 == s6);  // true</span><br></pre></td></tr></table></figure></p><h2 id="首先说明一点，在java-中，直接使用-操作符，比较的是两个字符串的引用地址，并不是比较内容，比较内容请用String-equals-。"><a href="#首先说明一点，在java-中，直接使用-操作符，比较的是两个字符串的引用地址，并不是比较内容，比较内容请用String-equals-。" class="headerlink" title="首先说明一点，在java 中，直接使用==操作符，比较的是两个字符串的引用地址，并不是比较内容，比较内容请用String.equals()。"></a>首先说明一点，在java 中，直接使用==操作符，比较的是两个字符串的引用地址，并不是比较内容，比较内容请用String.equals()。</h2><pre><code>s1 == s2这个非常好理解，s1、s2在赋值时，均使用的字符串字面量，说白话点，就是直接把字符串写死，在编译期间，这种字面量会直接放入class文件的常量池中，从而实现复用，载入运行时常量池后，s1、s2指向的是同一个内存地址，所以相等。</code></pre><hr><pre><code>s1 == s3这个地方有个坑，s3虽然是动态拼接出来的字符串，但是所有参与拼接的部分都是已知的字面量，在编译期间，这种拼接会被优化，编译器直接帮你拼好，因此String s3 = &quot;Hel&quot; + &quot;lo&quot;;在class文件中被优化成String s3 = &quot;Hello&quot;，所以s1 == s3成立。只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。</code></pre><hr><pre><code>s1 == s4当然不相等，s4虽然也是拼接出来的，但new String(&quot;lo&quot;)这部分不是已知字面量，是一个不可预料的部分，编译器不会优化，必须等到运行时才可以确定结果，结合字符串不变定理，鬼知道s4被分配到哪去了，所以地址肯定不同。对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中。</code></pre><hr><pre><code>s1 == s9也不相等，道理差不多，虽然s7、s8在赋值的时候使用的字符串字面量，但是拼接成s9的时候，s7、s8作为两个变量，都是不可预料的，编译器毕竟是编译器，不可能当解释器用，不能在编译期被确定，所以不做优化，只能等到运行时，在堆中创建s7、s8拼接成的新字符串，在堆中地址不确定，不可能与方法区常量池中的s1地址相同。</code></pre><h2 id="s4-s5已经不用解释了，绝对不相等，二者都在堆中，但地址不同。"><a href="#s4-s5已经不用解释了，绝对不相等，二者都在堆中，但地址不同。" class="headerlink" title=" s4 == s5已经不用解释了，绝对不相等，二者都在堆中，但地址不同。"></a> s4 == s5已经不用解释了，绝对不相等，二者都在堆中，但地址不同。</h2><pre><code>s1 == s6这两个相等完全归功于intern方法，s5在堆中，内容为Hello ，intern方法会尝试将Hello字符串添加到常量池中，并返回其在常量池中的地址，因为常量池中已经有了Hello字符串，所以intern方法直接返回地址；而s1在编译期就已经指向常量池了，因此s1和s6指向同一地址，相等。</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>等待唤醒(生产者与消费者)</title>
      <link href="/2018/11/14/JavaSe/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81/"/>
      <url>/2018/11/14/JavaSe/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>死锁的情况<br><a id="more"></a><br>一.同步嵌套<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Dead implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">        private boolean flag;</span><br><span class="line">        Dead(boolean flag)</span><br><span class="line">        &#123;</span><br><span class="line">           this.flag = flag;</span><br><span class="line">        &#125;</span><br><span class="line">        public void run()</span><br><span class="line">        &#123;    if(flag)</span><br><span class="line">              &#123;</span><br><span class="line">                   synchronized(Mylock.lock_A)</span><br><span class="line">                   &#123;  </span><br><span class="line">                      System.out.println(&quot;if...A&quot;);</span><br><span class="line">                      synchronized(Mylock.lock_B)</span><br><span class="line">                      &#123;</span><br><span class="line">                         System.out.println(&quot;if...B&quot;);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">              &#125;</span><br><span class="line">             else </span><br><span class="line">              &#123;</span><br><span class="line">                  synchronized(Mylock.lock_B)</span><br><span class="line">                   &#123;System.out.println(&quot;else...B&quot;);</span><br><span class="line">                      synchronized(Mylock.lock_A)</span><br><span class="line">                      &#123;System.out.println(&quot;else...A&quot;);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Mylock//锁</span><br><span class="line">&#123;</span><br><span class="line">    public static final Object lock_A = new Object();</span><br><span class="line">    public static final Object lock_B = new Object();</span><br><span class="line">&#125;              </span><br><span class="line">class Deaddemo</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">          Dead t1 = new Dead(true);</span><br><span class="line">          Dead t2 = new Dead(false);</span><br><span class="line">          new Thread(t1).start();</span><br><span class="line">          new Thread(t2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>等待唤醒机制：<br>wait():该方法可以让线程处于冻结状态，并将线程临时存储到线程池中。<br>notify():唤醒制定线程池中的任意一个线程。<br>notifyAll():唤醒指定线程池中的所有线程。<br>  这些方法必须使用在同步中，因为他们用来操作同步锁上的线程的状态的。<br>  在使用这些方法时，必须标识他们所属于的锁。标识方法就是  锁对象.wait();  锁对象.notify(); 锁对象.notifyAll();<br>  相同锁的notify()可以唤醒相同锁的wait();</p><h3 id="举例一："><a href="#举例一：" class="headerlink" title="举例一："></a>举例一：</h3><p>生产者消费者模式<br>模式目标：生产一个，消费一个。<br> *为什么使用等待唤醒机制:如果仅仅使用同步函数，会出现生产许多个才开始消费一个的情况，和现实生活不符合。</p><p>伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class 产品</span><br><span class="line">&#123;</span><br><span class="line">    生产()</span><br><span class="line">    &#123;</span><br><span class="line">       if(产品已存在)</span><br><span class="line">        &#123;</span><br><span class="line">          try&#123;wait()&#125;//执行wait，生产线程开始等待，此处的锁是this,所以可以省略</span><br><span class="line">          catch(InterruptedException e)&#123;&#125;//使用wait需要处理异常</span><br><span class="line">         &#125;</span><br><span class="line">        生产产品；</span><br><span class="line">        notify();//唤醒消费线程</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    消费()</span><br><span class="line">     &#123;</span><br><span class="line">        if(产品不存在）</span><br><span class="line">         &#123;</span><br><span class="line">            try&#123;wait()&#125;//执行wait，消费线程开始等待，此处的锁是this,所以可以省略</span><br><span class="line">            catch(InterruptedException e)&#123;&#125;//使用wait需要处理异常</span><br><span class="line">          &#125;</span><br><span class="line">         消费产品；</span><br><span class="line">         notify();//唤醒生产线程</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">class producer implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">    private 产品 A;</span><br><span class="line">    producer(产品 A)</span><br><span class="line">    &#123;</span><br><span class="line">       this.A=A;//此处是为了保证生产者和消费者操控的都是同一个对象，所以直接用构造函数获取同一个对象的实例。</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">       A.生产();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="举例二"><a href="#举例二" class="headerlink" title="举例二"></a>举例二</h3><p>生产消费模式<br>模式目标：多个生产，多个消费，生产一个，消费一个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Product </span><br><span class="line">&#123;</span><br><span class="line">String prod;</span><br><span class="line">int count=0;</span><br><span class="line">boolean p=false;</span><br><span class="line">public synchronized void pro()</span><br><span class="line">&#123;</span><br><span class="line">while(p)</span><br><span class="line">&#123;</span><br><span class="line">try</span><br><span class="line">&#123;wait();&#125;</span><br><span class="line">catch(InterruptedException e)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">count++;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;生产面包&quot;+count);</span><br><span class="line">p=true;</span><br><span class="line">notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">public synchronized void con()</span><br><span class="line">&#123;</span><br><span class="line">while(!p)</span><br><span class="line">&#123;</span><br><span class="line">try &#123;wait();&#125;</span><br><span class="line">catch(InterruptedException e) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;  消费面包&quot;+count);</span><br><span class="line">p=false;</span><br><span class="line">notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>代码优化</em>：<br>           问题是<em>会唤醒同为生产者的其他线程</em><br>           此时优化的部分是*将If改为while，这样就可以循环判断标记是否为空。</p><pre><code>此时的问题是*如果唤醒的是同类型，那么所有线程都会中断。此时优化的部分是*生产者生产完毕后等待，紧接着只能通过notifyAll来唤醒所有线程 最终问题：代码效率低下，多次循环判断以及唤醒所有线程，这些都会影响程序效率。</code></pre><h2 id="举例三：生产消费模式"><a href="#举例三：生产消费模式" class="headerlink" title="举例三：生产消费模式"></a>举例三：生产消费模式</h2><h2 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h2><p> 1.<br>  wait()必须指定时间，也可以不指定。<br>  sleep()必须指定时间。</p><p> 2.<br>  wait():释放cpu资源，释放锁。</p><h2 id="sleep-释放cpu资源，但是不释放锁。"><a href="#sleep-释放cpu资源，但是不释放锁。" class="headerlink" title="  sleep():释放cpu资源，但是不释放锁。 "></a>  sleep():释放cpu资源，但是不释放锁。 </h2><h2 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h2><p>需要注意的是<br>例子：<br> public synchronized void run()<br> {<br>       while(flag)<br>        {<br>             try{<br>                 wait();<br>                }<br>              catch(InterruptedException e )//此处抛出的异常是InterruptedException是因为<br>                                            //中断一个正在wait的线程时，会收到InterruptedException异常<br>                {<br>                   }<br>        }<br>  }</p><p> 在其他函数中改变flag的值以达到停止的效果，如果创建多个线程执行该操作，那么程序可能会发生死锁<br> （因为可能main线程停止后，该线程还处于wait状态，所有此时要用到中断）</p><p><strong>守护线程</strong>：后台线程<br>          前台线程结束后会自动结束<br><strong>join方法是等待某一线程停止</strong><br>使用例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    Thread t1 = new Thread();</span><br><span class="line">    t1.join();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><pre><code>此处代码的意义就是：main线程告诉CPU，结束自己的运行权限，并且等到t1运行结束后再开始运行。</code></pre><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>   setPriority()</p><p>#线程优先级有1-10等级划分</p><p>##通过 线程.setPriority() 修改线程的优先级。</p><p>   Thread.yield()</p><p>#暂停该线程并执行其他线程<br> 用处：线程交换更频繁</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE之多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程之单例模式</title>
      <link href="/2018/11/14/JavaSe/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/14/JavaSe/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程之单例模式"><a href="#多线程之单例模式" class="headerlink" title="多线程之单例模式"></a>多线程之单例模式</h1><p>饱汉式与饿汉式<br><a id="more"></a></p><p><strong>饿汉式</strong>：（相对较于安全）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Single</span><br><span class="line">&#123;</span><br><span class="line">    private static final Single SINGLE_INTSTANCE = new Single();</span><br><span class="line">    private Single()&#123;&#125;</span><br><span class="line">    public static Single getInstance()//函数内只有一个return，否则多线程可能会有安全问题。</span><br><span class="line">    &#123;</span><br><span class="line">        return SINGLE_INTSTANCE;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>饱汉式</strong>：延迟加载模式（在多线程并发访问时，会出现线程安全问题。）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> class Single</span><br><span class="line">&#123;</span><br><span class="line">    private static Single s = null;</span><br><span class="line">    private Single()&#123;&#125;</span><br><span class="line">    public static Single getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        if(s==null)</span><br><span class="line">         &#123;</span><br><span class="line">             s = new Single();</span><br><span class="line">             </span><br><span class="line">          &#125;</span><br><span class="line">          return s;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>*安全问题：//假设线程1判断完为null后进入if代码块却同时转换为线程2，则可能线程2new对象，使对象new多了。</p><hr><p>优化代码第一步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> class Single</span><br><span class="line">&#123;</span><br><span class="line">    private static Single s = null;</span><br><span class="line">    private Single()&#123;&#125;</span><br><span class="line">    public static synchronized Single getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        if(s==null)</span><br><span class="line">         &#123;</span><br><span class="line">             s = new Single();  </span><br><span class="line">          &#125; </span><br><span class="line">           return s;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>优化细节</em>：加入synchronized可以保证不会发生上述的安全问题。<br><em>代码缺陷</em>：线程每次都要判断有没有锁，然后再判断if，如此往复会降低效率。</p><hr><p>优化代码第二步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> class Single</span><br><span class="line">&#123;</span><br><span class="line">    private static Single s = null;</span><br><span class="line">    private Single()&#123;&#125;</span><br><span class="line">    public static Single getInstance()</span><br><span class="line">    &#123;</span><br><span class="line">        if(s==null)</span><br><span class="line">         &#123;</span><br><span class="line">             synchronize(Sing.class)</span><br><span class="line">             &#123;</span><br><span class="line">                if(s==null)</span><br><span class="line">                &#123;</span><br><span class="line">                   s = new Single();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         return s;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>优化细节</em>：转化成同步代码块，同时加入了两次if判断。<br>           当对象创建以后，线程就只需要进行一次if判断就可以结束了。</p><p>—-优化代码第三步</p><p><em>类级内部类方式</em></p><p>　　饿汉式会占用较多的空间，因为其在类加载时就会完成实例化，而懒汉式又存在执行速率慢的情况，双重加锁机制呢？又有执行效率差的毛病，有没有一种完美的方式可以规避这些毛病呢？</p><p>　　貌似有的，就是使用类级内部类结合多线程默认同步锁，同时实现延迟加载和线程安全。</p><p>单例模式最优方案<br>线程安全  并且效率高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonTest &#123; </span><br><span class="line"></span><br><span class="line">    // 定义一个私有构造方法</span><br><span class="line">    private SingletonTest() &#123; </span><br><span class="line">     </span><br><span class="line">    &#125;   </span><br><span class="line">    //定义一个静态私有变量(不初始化，不使用final关键字，使用volatile保证了多线程访问时instance变量的可见性，避免了instance初始化时其他变量属性还没赋值完时，被另外线程调用)</span><br><span class="line">    private static volatile SingletonTest instance;  </span><br><span class="line"></span><br><span class="line">    //定义一个共有的静态方法，返回该类型实例</span><br><span class="line">    public static SingletonTest getIstance() &#123; </span><br><span class="line">        // 对象实例化时与否判断（不使用同步代码块，instance不等于null时，直接返回对象，提高运行效率）</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            //同步代码块（对象未初始化时，使用同步代码块，保证多线程访问时对象在第一次创建后，不再重复被创建）</span><br><span class="line">            synchronized (SingletonTest.class) &#123;</span><br><span class="line">                //未初始化，则初始instance变量</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new SingletonTest();   </span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">        return instance;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　如上代码，所谓类级内部类，就是静态内部类，这种内部类与其外部类之间并没有从属关系，加载外部类的时候，并不会同时加载其静态内部类，只有在发生调用的时候才会进行加载，加载的时候就会创建单例实例并返回，有效实现了懒加载（延迟加载），至于同步问题，我们采用和饿汉式同样的静态初始化器的方式，借助JVM来实现线程安全。</p><p>　　其实使用静态初始化器的方式会在类加载时创建类的实例，但是我们将实例的创建显式放置在静态内部类中，它会导致在外部类加载时不进行实例创建，这样就能实现我们的双重目的：延迟加载和线程安全。</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE之多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程的锁</title>
      <link href="/2018/11/14/JavaSe/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%94%81/"/>
      <url>/2018/11/14/JavaSe/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程的锁"><a href="#多线程的锁" class="headerlink" title="多线程的锁"></a>多线程的锁</h1><h3 id="为什么需要锁？"><a href="#为什么需要锁？" class="headerlink" title="为什么需要锁？"></a>为什么需要锁？</h3><p>产生安全问题的原因：<br>1.线程任务中有处理到共享的数据。<br>2.线程任务中有多条对共享数据的操作。<br>  一个线程在操作共享数据的过程中，其他线程参与了运算，造成了数据的错误。<br><a id="more"></a></p><p>解决的思想：<br>      <strong>只要保证多条操作共享数据的代码在某一时间段，被一条线程所执行，在执行期间不允许其他线程参与运算。</strong></p><p>如何保证？</p><pre><code>1.同步代码块：          synchronized(对象)//对象的左右就是锁          {            需要同步的代码            }2.同步函数：          public synchronized void add(int n)//同步函数使用的是this           {            }           //函数需要被对象调用，同步函数使用的锁就是this。</code></pre><p> 好处：解决了多线程的安全问题。<br> 弊端：减低效率（其他线程需要先进行判断等待）</p><p><em>前提</em>：多个线程在同步中必须使用同一个锁，这才是同步。<br><em>使用的区别：</em><br>          <strong>如果说，一个类中如果需要多个锁，这时可以考虑同步函数，使用this，写法简单。          </strong>但是，一个类中如果需要多个锁，还有多个类中需要使用同一个锁，这时只能使用同步代码块。<br>          **建议主要使用同步代码块。</p><p>例 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class SaleTicket implements Runnable</span><br><span class="line">&#123;</span><br><span class="line">     private int tickets = 100;</span><br><span class="line">     Object obj = new Object();</span><br><span class="line">     public void run()</span><br><span class="line">     &#123;</span><br><span class="line">          while (true)</span><br><span class="line">           &#123;</span><br><span class="line">             synchronized(obj)</span><br><span class="line">               &#123;</span><br><span class="line">                   if(ticket&gt;0)</span><br><span class="line">                   &#123;</span><br><span class="line">                      try&#123;</span><br><span class="line">                          Thread.sleep(10);//让线程在这里停一下</span><br><span class="line">                          &#125;</span><br><span class="line">                      catch(InterruptedException e)</span><br><span class="line">                          &#123;</span><br><span class="line">                           &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>如果同步函数被static修饰<br>static方法随着类加载，这时不一定有该类的对象，但是一定有一个该类的字节码文件对象。<br>这个对象的简单表示方法就是 类名.class 描述类是用Class</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE之多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程入门</title>
      <link href="/2018/11/14/JavaSe/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2018/11/14/JavaSe/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程详解"><a href="#多线程详解" class="headerlink" title="多线程详解"></a>多线程详解</h1><p><strong>进程</strong>：就是应用程序在内存中分配的空间。（正在运行中的程序）<br><strong>线程</strong>：是进程中负责程序执行的执行单元。<br>一个进程中至少有一个线程在负责该进程的运行，<br>如果一个进程出现了多个线程，就称该程序为多线程程序。<br><a id="more"></a></p><h2 id="Thread类创建线程的方法"><a href="#Thread类创建线程的方法" class="headerlink" title="Thread类创建线程的方法"></a>Thread类创建线程的方法</h2><p>1.继承Thread类<br>2.覆盖run方法<br>3.创建子类对象就是创建线程对象<br>4.调用Thread类中的start方法就可以执行线程，并会调用run方法</p><p>举例说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Demo extends Thread</span><br><span class="line">&#123;</span><br><span class="line">String name;</span><br><span class="line">public Demo(String name)</span><br><span class="line">&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;5;i++)</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;...&quot;+name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ThreadDemo &#123;</span><br><span class="line">public static void main(String args[])</span><br><span class="line">&#123;</span><br><span class="line">Demo A = new Demo(&quot;a&quot;);</span><br><span class="line">Demo B = new Demo(&quot;b&quot;);</span><br><span class="line">A.start();</span><br><span class="line">B.run();</span><br><span class="line">for(int i=0;i&lt;5;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+&quot;...&quot;+&quot;C&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果：<br>main…b<br>Thread-0…a<br>main…C（略）<br><strong>原因：</strong><br>     这里就要谈到调用start和调用run的区别<br>     start会完成两件事：1.开启线程，2.调用run方法<br>     所以用start才是开启多线程，run实际上还是原来的线程。</p><h2 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h2><p>过程如下：<br>1.定义一个类实现Runnable。<br>2.覆盖Runnable接口中的run方法，将线程要运行的任务代码存储到该方法中。<br>3.通过Thread类创建线程对象，并将实现了Runnable接口的对象作为Thread类的构造函数的参数进行传递。<br>4.调用Thread类的start方法，开启线程。</p><p>好处：<br>1，避免了继承Thread类的局限性（student是person的子类，就无法再多继承Thread，所以必须用Runnable）<br>2.Runnable接口出现更符合面向对象，将线程单独进行对象的封装。<br>3.Runnable接口出现，降低了线程对象和线程任务的耦合性。</p><p><strong>综上所述，以后创建线程多使用Runnable</strong></p>]]></content>
      
      
      <categories>
          
          <category> JAVASE之多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多线程getName()方法</title>
      <link href="/2018/11/14/JavaSe/%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8BgetName-%E6%96%B9%E6%B3%95/"/>
      <url>/2018/11/14/JavaSe/%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8BgetName-%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>先说定义</strong>：<br>this.getName()是一个实例方法：反映这个实例的情况,实例指的就是这个类的对象<br>Thread.currentThread().getName() 是一个静态方法：反映这个实体的情况,实体却不一样，实体是指正在发生这个作用的实例<br><a id="more"></a><br><strong>接下来具体说明</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Demo1 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">String name;</span><br><span class="line">public Demo(String name)</span><br><span class="line">&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public void run()</span><br><span class="line">&#123;System.out.println(Thread.currentThread().getName()+&quot;...&quot;+name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Demo2 extends Thread</span><br><span class="line">&#123;</span><br><span class="line">String name;</span><br><span class="line">public Demo(String name)</span><br><span class="line">&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(getName()+&quot;...&quot;+name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ThreadDemo &#123;</span><br><span class="line">public static void main(String args[])</span><br><span class="line">&#123;</span><br><span class="line">Demo A = new Demo(&quot;a&quot;);</span><br><span class="line">Demo B = new Demo(&quot;b&quot;);</span><br><span class="line">A.start();</span><br><span class="line">                A.run();</span><br><span class="line">                B.start();</span><br><span class="line">B.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果<br>main…a<br>Thread-0…a<br>Thread-1…b<br>Thread-1…b<br>（顺序不影响）<br>（这里就要谈到调用start和调用run的区别<br>     start会完成两件事：<strong>1.开启线程 2.调用run方法</strong><br>     所以用start才是开启多线程，run实际上还是原来的线程。）</p><p>打印出 main…a 的原因是<strong>因为T.c().g()方法返回的是实际上调用start方法的对象的线程名，A.run()并没有创建新线程</strong><br>打印出 Thread-0…a 的原因是因为<strong>A.start()创建了新线程。</strong><br>那么为什么调用B.run()却打印出 Thread-1…b 的原因是因为<strong>getName()方法返回的是this指向的对象的线程名（run定义了该线程该如何做，但实际运行该线程的是main线程）所以打印Thread-1，但实际上是main在运行。</strong></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><h2 id="Thread-currentThread-getName-是获得调用这个方法的线程的名字"><a href="#Thread-currentThread-getName-是获得调用这个方法的线程的名字" class="headerlink" title="Thread.currentThread().getName()是获得调用这个方法的线程的名字"></a>Thread.currentThread().getName()是获得调用这个方法的线程的名字</h2><h2 id="this-getName-这个方法是获取当前对象的名字"><a href="#this-getName-这个方法是获取当前对象的名字" class="headerlink" title="this.getName()这个方法是获取当前对象的名字"></a>this.getName()这个方法是获取当前对象的名字</h2>]]></content>
      
      
      <categories>
          
          <category> JAVASE之多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA异常处理</title>
      <link href="/2018/10/20/JavaSe/JAVA%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2018/10/20/JavaSe/JAVA%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA异常处理"><a href="#JAVA异常处理" class="headerlink" title="JAVA异常处理"></a>JAVA异常处理</h1><p>异常是程序的一种错误，但并不是错误就是异常。<br><strong>异常</strong>：<em>Exception</em><br><strong>错误</strong>：<em>Error</em><br><a id="more"></a><br>我的理解是：<br>Error是系统的错误，比如栈内存溢出等，Error是编译无法检查出来的，只能通过运行后检查出来。这种是脱离了程序员所能操控的问题范围，所以Error只能停止运行并进行代码修改。<br>而Exception是程序的错误，这种错误是可以处理的。<br>总的来说，Exception分为两种<br><strong>检查型错误</strong>(<em>IOException</em>):编译时会被检查出来的异常。例如要打开一个不存在文件，这些异常在编译时不能被简单地忽略。<br><strong>非检查型异常</strong>或称<strong>运行时异常</strong>(RuntimeException)：编译可以通过的异常，所以可以通过程序员的处理来避免的异常。</p><p><em>JAVA的异常处理就是指的是处理RuntimeException型的异常。Java中的异常可以是函数中的语句执行时引发的，也可以是程序员通过throw 语句手动抛出的，只要在Java程序中产生了异常，就会用一个对应类型的异常对象来封装异常，JRE就会试图寻找异常处理程序来处理异常。</em></p><p>异常处理主要分为<strong>抛出</strong>和<strong>捕获</strong></p><h2 id="抛出"><a href="#抛出" class="headerlink" title="抛出"></a>抛出</h2><h3 id="将异常抛给调用者"><a href="#将异常抛给调用者" class="headerlink" title="将异常抛给调用者"></a>将异常抛给调用者</h3><p><strong>throws</strong>和<strong>throw</strong>：<br>throws语句用在方法声明后面，表示再抛出异常，由该方法的调用者来处理。主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。</p><p>throw语句用在方法体内，是具体向外抛异常的动作，倾向变成真实的。表示抛出异常，由方法体内的语句处理。</p><p>Exception分为两种<br>{   1，编译时会被检测的异常<br>2，运行时异常（RuntimeException)<br>}</p><p>关于RuntimeException的一些特例<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Demo</span><br><span class="line">&#123;     </span><br><span class="line">       int div(int a,int b)throws Exception//此处必须要进行throws的声明</span><br><span class="line">      &#123;</span><br><span class="line">             if(b==0)</span><br><span class="line">                  throw new Exception();</span><br><span class="line">             return a/b;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Demo</span><br><span class="line">&#123;     </span><br><span class="line">       int div(int a,int b) //此处无throws的声明</span><br><span class="line">      &#123;</span><br><span class="line">             if(b==0)</span><br><span class="line">                  throw new ArithmeticException();</span><br><span class="line">             return a/b;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结：可能在执行方法期间抛出但未被捕获的RuntimeException的任何子类<br>      都无需在throws子句中进行声明。<br>      why?<br>      并不是不能用throws声明，而是并不去声明，因为如果用throws声明，<br>      调用者假如进行捕获处理，继续运行，但如果该异常会影响到后边代码，<br>      那么就会产生很多麻烦，所以不声明的目的其实就是为了停止运行。<br>      So 可以使用，但没必要。</p><h2 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h2><h3 id="捕获异常并处理"><a href="#捕获异常并处理" class="headerlink" title="捕获异常并处理"></a>捕获异常并处理</h3><p>使用 try 和 catch 关键字可以捕获异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">   // 程序代码</span><br><span class="line">&#125;catch(ExceptionName e1)</span><br><span class="line">&#123;</span><br><span class="line">   //Catch 块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将可能会出现异常的代码块放在try中，一旦try中捕获到了异常对象，便会执行catch块中的代码，进行异常处理。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Demo&#123;</span><br><span class="line">int div(int a,int b) &#123;</span><br><span class="line">return a/b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Test &#123;</span><br><span class="line">    int a,b;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"> Demo d = new Demo();</span><br><span class="line"> </span><br><span class="line"> try &#123; </span><br><span class="line"> int num=d.div(3, 0);</span><br><span class="line"> System.out.println(num);</span><br><span class="line"> &#125;</span><br><span class="line"> catch(Exception e) &#123;</span><br><span class="line"> System.out.println(e.getMessage());</span><br><span class="line"> System.out.println(&quot;hhh&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">        System.out.println(&quot;over&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当catch处理以后，程序不会停止，而会继续运行。</p><p><strong>综上所述</strong>：JAVA中的异常处理分离了接收和处理错误代码。这个功能理清了编程者的思绪，也帮助代码增强了可读性，方便了维护者的阅读和理解。 </p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>接口与继承</title>
      <link href="/2018/10/14/JavaSe/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
      <url>/2018/10/14/JavaSe/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA的接口与继承"><a href="#JAVA的接口与继承" class="headerlink" title="JAVA的接口与继承"></a>JAVA的接口与继承</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>  在Java中，使用extends关键字实现继承，extends后跟的是父类名，也就是它从哪个类继承过来的，而用extends的这个类本身称为子类。<br><a id="more"></a><br><--more--></--more--></p><h3 id="子父类构造函数详解"><a href="#子父类构造函数详解" class="headerlink" title="子父类构造函数详解"></a>子父类构造函数详解</h3><pre><code>当一个类继承了某个类时，在子类的构造方法里，super()必须先被调用；如果你没有写，编译器会自动调用super()方法，即调用了父类的构造方法；这并不是创建了两个对象，其实只有一个子类Sub对象；之所以需要调用父类的构造方法是因为在父类中，可能存在私有属性需要在其构造方法内初始化；当编译器自动插入父类构造方法的调用后，子类的构造方法类似如下代码：例如：public zi() {       super();//注意，如果不写这个，系统也会自动默认补上。        System.out.println(&quot;zi&quot;);      }this()函数和super()函数都必须在第一行，所以出现this就没有super，反之亦然</code></pre><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>　　简单来说就是，如果子类方法名和父类方法名相同，那么子类就不能继承父类的方法，此时称子类的方法重写了父类的方法。重写也可称为覆盖。</p><h3 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h3><h2 id="子类可以调用父类声明的构造方法，但是必须在子类的构造方法中使用super关键字来调用；如果想在子类中操作父类中被隐藏的成员变量和被重写的成员方法，也可以使用super关键字。这些在以后的项目中会出现，这里就不举例了，如果使用Java编译器的话，需要使用super关键字但未使用时编译器会有错误提示。"><a href="#子类可以调用父类声明的构造方法，但是必须在子类的构造方法中使用super关键字来调用；如果想在子类中操作父类中被隐藏的成员变量和被重写的成员方法，也可以使用super关键字。这些在以后的项目中会出现，这里就不举例了，如果使用Java编译器的话，需要使用super关键字但未使用时编译器会有错误提示。" class="headerlink" title="　　子类可以调用父类声明的构造方法，但是必须在子类的构造方法中使用super关键字来调用；如果想在子类中操作父类中被隐藏的成员变量和被重写的成员方法，也可以使用super关键字。这些在以后的项目中会出现，这里就不举例了，如果使用Java编译器的话，需要使用super关键字但未使用时编译器会有错误提示。"></a>　　子类可以调用父类声明的构造方法，但是必须在子类的构造方法中使用super关键字来调用；如果想在子类中操作父类中被隐藏的成员变量和被重写的成员方法，也可以使用super关键字。这些在以后的项目中会出现，这里就不举例了，如果使用Java编译器的话，需要使用super关键字但未使用时编译器会有错误提示。</h2><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Java语言只支持单重继承，不支持多继承。这句话的意思就是一个类只能有一个父类，但我们经常需要使用多继承来解决问题，所以Java语言提供了接口来实现类的多重继承功能。<br>Java中使用interface来定义一个接口，接口定义与类相似（类的定义用的是class）</p><h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><h2 id="接口的实现类需要使用implements关键字，一个类可以实现多个接口，写法就是implements后的接口间以“，”隔开即可。如果变量冲突，则通过“接口名-变量”来明确指定变量的接口。"><a href="#接口的实现类需要使用implements关键字，一个类可以实现多个接口，写法就是implements后的接口间以“，”隔开即可。如果变量冲突，则通过“接口名-变量”来明确指定变量的接口。" class="headerlink" title="接口的实现类需要使用implements关键字，一个类可以实现多个接口，写法就是implements后的接口间以“，”隔开即可。如果变量冲突，则通过“接口名.变量”来明确指定变量的接口。"></a>接口的实现类需要使用implements关键字，一个类可以实现多个接口，写法就是implements后的接口间以“，”隔开即可。如果变量冲突，则通过“接口名.变量”来明确指定变量的接口。</h2><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>在Java中，通常使用方法的重载和重写实现类的多态性。<br>重写在上面已经介绍过了，而方法的重载是指在一个类中出现多个方法名相同，但参数个数或参数类型不同的方法<br><em>1，变量：</em><br>    子父类中有重名变量，多态调用时，<br>    只看调用该成员变量的引用所属的类中的成员变量！<br>       例如： fu有num=4,zi有num=6。<br>              fu f = new zi();<br>              那么输出f.num的值为4。<br>              如果fu没有num,则无法编译成功！！！！<br>     总结：无论编译还是运行都看等号左边的。</p><p><em>2，函数：</em><br>    子父类中有重名函数，多态调用时，<br>    fu f = new zi();<br>    编译时，看的是引用变量所属的类中的方法。<br>    运行时，看的是对象所属的类中的方法。<br>     总结：编译看左，运行看右</p><p><em>3，静态函数：</em><br>    子父类有重名函数，多态调用时，<br>    编译和运行都看引用变量所属的类中的方法。<br>     总结：编译运行都看等号左边的。</p><pre><code>多态：父类的引用或者接口引用指向了子类的对象</code></pre><h3 id="多态的转型"><a href="#多态的转型" class="headerlink" title="多态的转型"></a>多态的转型</h3><p><strong>一.向上转型</strong><br>{<br>好处：隐藏了子类型，提高了扩展性。<br>弊端：只能使用父类的功能，不能使用子类的特有功能。</p><pre><code>*如果不需要面对子类型，同时提高扩展性，或者使用父类的功能即可完成操作，就      使用向上转型</code></pre><p>}</p><p><strong>二.向下转型</strong><br>{<br>好处：可以使用子类型的特有功能。<br>弊端：必须面对具体的子类型。<br>      *向下转型有风险，容易发生classcastException,只要转换类型和对象类型不匹       配就会发生！！！！<br>       所以需要使用 Instanceof<br>       例如：  对象 instanceof 类型</p><h2 id><a href="#" class="headerlink" title="}      "></a>}      </h2><p>话不多说，直接来一道我学习过程中受益很大的一道题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class DispatchTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">fu b = new zi();</span><br><span class="line">                System.out.println(b.x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class fu &#123;</span><br><span class="line"> </span><br><span class="line">int x = 10;</span><br><span class="line"> </span><br><span class="line">public fu() &#123;</span><br><span class="line">this.printMessage();</span><br><span class="line">x = 20;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void printMessage() &#123;</span><br><span class="line">System.out.println(&quot;fu.x = &quot; + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class zi extends fu &#123;</span><br><span class="line">     int x = 30;</span><br><span class="line">    </span><br><span class="line">public zi() &#123;</span><br><span class="line">this.printMessage();</span><br><span class="line">x = 40;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void printMessage() &#123;</span><br><span class="line">System.out.println(&quot;zi.x=&quot; + x);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果为<br>zi.x=0<br>zi.x=30<br>20<br><strong>解析</strong><br>这里就要谈到JAVA类中属性的构造了，首先new zi类以后，zi类调用了super构造函数，<br>然后fu的构造函数被调用，初始化了父类所属的x为10（注意，此处的原理并不是父类<br>x还未赋值！），紧接着调用了zi类中的printmessage函数，原因是因为继承关系中，<br>子类的函数功能会覆盖掉父类的同名函数，而属性并不会被覆盖（也就是说x变量并不是<br>被覆盖，而是堆内存中出现了两个，一个是this.x，一个是super.x），所以第一个打印<br>结果是zi.x=0说明调用的是zi的打印函数，此处打印的值也是this.x，也就是还没有初始化的zi类x，所以是0。第二个就好理解了，在super构造结束后开始子类初始化，此时<br>zi类的x被赋值为30了，所以打印出30。最后一处打印出20的原因是因为，fu的构造函数<br>最后一步将20赋值给了super.x，然后因为多态中用的是 fu b = new zi(),所以b是fu类<br>的，要打印fu的x就应该找到super.x，所以打印出20。</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内部类</title>
      <link href="/2018/10/14/JavaSe/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2018/10/14/JavaSe/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="java内部类"><a href="#java内部类" class="headerlink" title="java内部类"></a>java内部类</h1><a id="more"></a><p><strong>1,非私有 非静态内部类</strong><br>     例：outer.inner demo = new outer().new inner()<br><strong>2,非私有 静态内部类</strong><br>      访问非静态成员：例：outer.inner demo = new outer.inner()<br>                          demo.show();<br>      访问静态成员：  例：outer.inner.show();</p><p><em>非静态内部类中的静态方法是不被允许的</em><br>         原因：静态方法不需要new就可以使用，<br>             但是非静态内部类必须new才能使用。违背了原则。<br><em>非静态内部类中可以定义静态常量！必须使用final</em><br>         例如：static final int num = 5;<br>         原因：当编译完以后，其实num在字节码文件中就变成5了，不是变量。</p><h2 id="内部类在外部类中的情况"><a href="#内部类在外部类中的情况" class="headerlink" title="内部类在外部类中的情况"></a>内部类在外部类中的情况</h2><p><strong>编译后产生的文件名称</strong>：outer$inner //此处若带数字代表是局部内部类<br>举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class outer</span><br><span class="line">&#123;</span><br><span class="line">       </span><br><span class="line">      Object ob;</span><br><span class="line">      public void method()</span><br><span class="line">       &#123;</span><br><span class="line">           final int x = 5;//强调！！！此处必须加final！！！</span><br><span class="line">           class inner</span><br><span class="line">           &#123;</span><br><span class="line">              void show()</span><br><span class="line">               &#123;</span><br><span class="line">                 System.out.println(x);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">          inner in = new inner(); </span><br><span class="line">          in.show();</span><br><span class="line">          ob = in;//用ob保存下in保存的对象地址，</span><br><span class="line">                  //等method结束以后，in消失，但对象还在，用ob保存了</span><br><span class="line">                  //同理，如果不用final定义常量，那么等到method方法结束</span><br><span class="line">                  //用ob调用show方法就找不到x了，所以JAVA中不允许编译通过！</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>总结：局部内部类只能访问被final修饰的局部变量</strong></p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p><strong>匿名内部类其实就是子类</strong></p><p>前提：内部类需要继承或者实现外部的类或者接口</p><p>格式：new 父类/接口名 ()<br>        {<br>           子类的内容<br>        }</p><p>调用例子：<br>       abstrcat class Demo<br>       {  abstrcat void show();}</p><pre><code>class outer{   public void method()   {       new Demo()        {           public void show()           {             System.out.println(&quot;show&quot;);            }         }.show//从此处直接调用show    } } 当多方法时候可以直接 Demo a = new Demo(){........                                          }                     然后a.show1;a.show2;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>约瑟夫环</title>
      <link href="/2018/08/20/%E7%AE%97%E6%B3%95/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
      <url>/2018/08/20/%E7%AE%97%E6%B3%95/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p><em>约瑟夫环</em><br><a id="more"></a><br><strong>约瑟夫环问题可简化为：</strong><br>编号为1，2，…，n的n个人按顺时针方向围坐在一张圆桌周围，每人持有一个密码（正整数）。一开始任选一个正整数m作为报数上限值，从第一个人开始按顺时针方向自1开始报数，报到m时停止报数，报m的那个人出列，将他的密码作为新的m值，从他顺时针方向的下一个人开始重新从1报数，数到m的那个人又出列；如此下去，直至圆桌周围的人全部出列为止。要求按出列顺序输出n个人的编号。</p><hr><p>由题可知，我们需要先构建一个结构体，其中包括了每个人的编号和密码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct node</span><br><span class="line">&#123;</span><br><span class="line">int id;//**编号**</span><br><span class="line">int pas;//**密码**</span><br><span class="line">struct node *next; </span><br><span class="line"> &#125;node,*Lnode;</span><br></pre></td></tr></table></figure></p><p>接下来我的思路是构建一个单向循环链表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Lnode create(Lnode L,int n)//用n代表人数</span><br><span class="line"> &#123;</span><br><span class="line"> L=(Lnode)malloc(sizeof(node));</span><br><span class="line"> Lnode p,q;</span><br><span class="line"> p=L;</span><br><span class="line"> int i=1;</span><br><span class="line"> while(n&gt;0)</span><br><span class="line"> &#123;</span><br><span class="line">    q=(Lnode)malloc(sizeof(node));</span><br><span class="line"> p-&gt;next=q;</span><br><span class="line"> scanf(&quot;%d&quot;,&amp;q-&gt;pas);//输入每个人的密码</span><br><span class="line"> q-&gt;id=i;</span><br><span class="line"> p=q;</span><br><span class="line"> n--;</span><br><span class="line"> i++;</span><br><span class="line"> &#125;</span><br><span class="line"> q-&gt;next=L-&gt;next;</span><br><span class="line"> return L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来就是实现约瑟夫环，我的思路是若第x个人退出，那么就让指针移动到x-1的位置，然后输出x的编号以后进行删除，令X-1指向X+1。<br>这个问题还有一些特殊情况需要处理，比如如果刚开始只有一个人，则用if判断以后直接输出编号也就是1就行了，若还剩下两个人，我取巧，直接进行一个奇偶数判定，奇数的话就先输出该节点的编号，偶数就先输出next的编号，然后再输出自身的编号。<br>代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">  int ysf(int m,int n) &#123;</span><br><span class="line">  Lnode L=create(L,n),p,q;</span><br><span class="line">p=L-&gt;next;</span><br><span class="line">int x;</span><br><span class="line">x=n;</span><br><span class="line">if(n==1)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d&quot;,p-&gt;id);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">while(n&gt;1)</span><br><span class="line">&#123; x=n;</span><br><span class="line">if(m==1)</span><br><span class="line">&#123;</span><br><span class="line">if(n&gt;2)</span><br><span class="line">&#123;</span><br><span class="line">for(x=(n-1);x&gt;0;x--)</span><br><span class="line">&#123;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d&quot;,p-&gt;next-&gt;id);printf(&quot; &quot;);</span><br><span class="line">m=p-&gt;next-&gt;pas;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">        p-&gt;next=q-&gt;next;</span><br><span class="line">        free(q) ;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        n--;</span><br><span class="line">       &#125;</span><br><span class="line">        else if(n==2)&#123;</span><br><span class="line">        printf(&quot;%d&quot;,p-&gt;id);printf(&quot; &quot;);</span><br><span class="line">        printf(&quot;%d&quot;,p-&gt;next-&gt;id);</span><br><span class="line">        n--;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">else if(m!=1)&#123;</span><br><span class="line"></span><br><span class="line">            if(n==2)&#123;</span><br><span class="line">            if(m%2==1)</span><br><span class="line">                    &#123;printf(&quot;%d&quot;,p-&gt;id);printf(&quot; &quot;);</span><br><span class="line">                    printf(&quot;%d&quot;,p-&gt;next-&gt;id);</span><br><span class="line">                    n--;&#125;</span><br><span class="line">               else &#123;printf(&quot;%d&quot;,p-&gt;next-&gt;id);printf(&quot; &quot;);</span><br><span class="line">      printf(&quot;%d&quot;,p-&gt;id);</span><br><span class="line">                         n--;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">           </span><br><span class="line">    else&#123; x=m;</span><br><span class="line">           for(;x&gt;2;x--)</span><br><span class="line">    &#123; p=p-&gt;next;&#125;           </span><br><span class="line"></span><br><span class="line">            printf(&quot;%d&quot;,p-&gt;next-&gt;id);printf(&quot; &quot;);</span><br><span class="line">            m=p-&gt;next-&gt;pas;</span><br><span class="line">    q=p-&gt;next;</span><br><span class="line">            p-&gt;next=q-&gt;next; </span><br><span class="line">free(q) ;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">            n--;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>以上便是我对约瑟夫环的理解。</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
